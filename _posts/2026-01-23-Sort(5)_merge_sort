
//앞에서 말한 합병정렬의 경우, 배열로 구현되었었다. 그렇다면 전에도 서술하듯이 레코드의 수가 많다면 이동횟수가 매우 많아진다.
//이러한 단점을 해결하기 위해 연결리스트 기반으로 구현한 합병 정렬을 보자. 알고리즘 자체는 똑같다. 

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* next;
} Node;

void split_list(Node* source, Node** front, Node** back) {  //잘 생각하자. front와 back은 이리 생각해도 된다. '연결리스트의 시작 노드를 가르키는 head 포인터를 바꾸기(지정하기) 위한 이중포인터.
    Node* slow = source; //slow는 입력한 노드
    Node* fast = source->next; //fast는 source노드의 다음 노드

    //런너 기법이다.  연결 리스트 순회 시 2개의 포인터를 동시에 사용하는 기법이며, 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간위치를 판별할 때 쓰고는 한다.
    //중요한 것은 fast runner와 slow runner 간의 step을 2배 차이를 두는 것이다.
    while (fast != NULL) {
        fast = fast->next;
        if (fast != NULL) {
            slow = slow->next;
            fast = fast->next;
        } //코드 전체를 보면 fast가 NULL에 도달하지 않았다면, fast는 2칸, slow는 한칸씩 간다.
    }

    *front = source; //자 이제 보자. *front는 처음 노드를 가르키고
    *back = slow->next; // *back은 slow(전체 연결리스트의 중간지점)의 다음 노드를 가르키게 된다.
    slow->next = NULL; //오해하지 말자. 다음 노드를 지우는 것이 아니다. '링크필드' 의 포인터가 다음 노드를 가르키지 못하게 끊었을 뿐이다. 
    //합병정렬의 알고리즘이 이리 된것이다. 이 함수는 배열에서 두개의 부분배열로 분할하는 함수와 같은 역할을 한다.
}




Node* merge(Node* a, Node* b) {
    if (a == NULL) return b;  
    if (b == NULL) return a;

    if (a->data <= b->data) { //만약 두 노드의 데이터필드에 있는 데이터중 b가 더 크거나 같을 경우
        a->next = merge(a->next, b); //a의 링크필드 포인터에는 merge의 함수 반환값을 저장한다.
        //이게 어떻게 저장될까. 예컨대, 하나의 노드로 이루어진 두개의 부분 연결리스트가 있다고 하자. 그리고 b의 데이터가 더 크다고 치자.
        //그러면 merge(NULL, b) 이렇게 된다. 이후 저 호출에서는 위의 if문에 의해 b를 반환하게 된다. 즉 a의 링크필드에 b를 가르키게 저장되거니와, a->b 이런 순서로 제대로 합병 및 정렬이 되게 된다.
        return a; //이후 합병된 연결리스트의 시작노드 주소 a를 반환한다.
    }
    else {
        b->next = merge(a, b->next);
        return b;
    }
}

void merge_sort(Node** head_ref) {
    Node* head = *head_ref; //전체 연결리스트의 헤드포인터
    Node* a;
    Node* b;

    if (head == NULL || head->next == NULL)
        return;

    split_list(head, &a, &b); //연결리스트를 2개의 부분 연결리스트로 쪼갠다.

    merge_sort(&a); //이후 순환호출한다. 이때 *a 와 *b 모두 이중포인터 인자로 인하여 실제로 값이 바뀐다. 어떻게..? a는 시작 포인터 노드로, b는 중간 포인터노드 + 1 을 가르키게끔.
    merge_sort(&b); 

    *head_ref = merge(a, b); //그렇게 충분히 연결리스트를 계속 반복하여 쪼개고 나면, 어느 순간 if문에 걸릴때가 있을 것이다. 이제 그때를 기반으로 다시 천천히 돌아오거니와. 
    //합병을 하나하나씩 시킨다.

}

//다시 예시를 들어보자. [8,3,5,1] 이라고 치자. (단 모두 연결리스트로 하나로 이루어져 있는 것이다. 표시 편의를 위해 배열처럼 쓴다)
//split_list 으로 인하여, a는 8 노드를, b는 5의 노드를 가르키게 된다. 이후에 merge_sort으로 순환호출이 된다.
//merge_sort(&a) 를 보자. if문에 안걸리며, split_list를 다시 했을때, slow는 8, fast는 NULL 이 되므로, a는 8을 가르키게, b는 3을 가르키게 되며, a가 가르키는 노드의 링크필드 또한 NULL이 된다. b의 링크필드는 이미 전 순회에서 NULL이 되었을 것이고.
//그럼 이제 다음 호출  merge_sort(&a);과 merge_sort(&b)의 경우에는 바로 if 문에 걸려 멈춘다. 이제 merge(a,b) 가 되거니와, 합병이 되어 연결리스트가  [3,8] 이렇게 되어진다.
// 이후 나머지도 같다.

Node* push(Node* head, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = head;
    return newNode;
}

void print_list(Node* head) {
    while (head) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

int main() {
    Node* head = NULL;

    head = push(head, 1);
    head = push(head, 5);
    head = push(head, 3);
    head = push(head, 8);


    printf("정렬 전:\n");
    print_list(head);

    merge_sort(&head);

    printf("정렬 후:\n");
    print_list(head);

    return 0;
}

//최종적으로 배열의 경우와 연결리스트의 복잡도 비교를 해보자.
//우선 비교연산은 배열 합병이든, 연결리스트 합병이든 모두 같다. O(n log n) 이다.
//주요한 차이는 이동연산이다. 연결리스트의 합병의 경우에는 데이터를 직접 이동하고 대입하는 것이 아니라, 포인터만을 변경하는 것이기 때문에 복잡도가 O(1) 이 된다.
//해봤자 데이터 변경이 아닌 포인터 변경의 입장에서 포인터의 변경이 n log n번 이루어지나 이것 마저도, 배열 기반 합병 정렬보다 훨씬 효율적이다.
//추가로 레코드가 클 수록, 그러니까 다시 말하자면 배열의 요소가 '숫자'가 아니라면 데이터의 이동은 더욱 더 시간이 많이 걸릴것이다. 반면에 연결리스트 합병은 데이터의 크기와 관계없이 포인터만 이동하기에 효율적이다.
