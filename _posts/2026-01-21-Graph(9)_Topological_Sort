// 위상 정렬
// 순서가 있는 그래프 중, 선행 관계에 따라서 순서를 위배하지 않게 정렬하는 동시에 모든 정점을 나열하는 것을 위상 정렬이라고 한다.
// 예컨대, 자료구조를 배우기 위해서는 프로그래밍 언어를 배워야 하듯이. 이러한 관계는 보통 방향 그래프로 표현된다.
// 위상정렬의 알고리즘은 이렇다. 진입 차수가 0인 정점을 선택하고, 그 정점과 정점에 부착된 모든 간선을 삭제한다. 이런식으로 진입차수가 0인 것을 계속 반복하여 실행한다.
// 만약 진입차수가 0인 정점이 여러개 있다면 뭘 선택하든 순서는 상관 없다. 그러나 만약 어느 순간 진입차수가 0인 정점이 없다면 위상 정렬이 불가능 한 그래프인 셈이다. (사이클 과 같은 이유로)


#include <stdio.h>
#include <stdlib.h>
#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 50

typedef struct GraphNode {
	int vertex; //정점 번호
	struct GraphNode* link;
}GraphNode;

typedef struct GraphType {
	int n; //정점의 수
	GraphNode* adj_list[MAX_VERTICES];  //각 연결리스트의 헤드노드를 저장하는 배열이라 생각해도 된다. 

void graph_init(GraphType* g) { //그래프 초기화
	int v;
	g->n = 0;  //정점의 수 0
	for (v = 0; v < MAX_VERTICES; v++)
		g->adj_list[v] = NULL;
}

void insert_vertex(GraphType* g, int v) {
	if (((g->n) + 1) > MAX_VERTICES) {
		printf(stderr, "그래프: 정점의 개수 초과");
		return;
	}
	g->n++;  //정점 삽입 연산은, 단순 n 증가
}

void insert_edge(GraphType* g, int u, int v) { //간선 삽입 연산. v를 u의 인접 리스트에 삽입한다.
	GraphNode* node;
	if (u >= g->n || v >= g->n) {
		fprintf(stderr, "그래프: 정점 번호 오류");
		return;
	}
	node = (GraphNode*)malloc(sizeof(GraphNode)); //하나의 노드 생성.
	node->vertex = v; //node의 vertex에 v삽입
	node->link = g->adj_list[u]; //새 노드의 링크필드가 원래 헤드노드를 가르키게 한뒤

	g->adj_list[u] = node;  //헤드노드를 새로 삽입한 노드로 교체. 즉 이 삽입방식은 머리 삽입의 방식이며, 삽입할때마다 계속해서 헤드 노드가 삽입된 새로운 노드로 바뀌는 것이다.
	//어찌 되었든 이렇게 생각하자. u는 인덱스 번호, 즉 노드의 번호를 뜻하거니와, 그에 붙여진 인자 v는 다른 노드의 번호로, u에 연결될거니와, 연결리스트로 표현된것이다.

}

#define MAX_STACK_SIZE 100
typedef int element;
typedef struct {
	element stack[MAX_STACK_SIZE];
	int top;
}StackType;

void init(StackType* s) {
	s->top = -1;
}

int is_empty(StackType* s) {
	return (s->top == -1);
}

int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}

void push(StackType* s, element item) {
	if (is_full(s)) {
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->stack[++(s->top)] = item;
}

element pop(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->stack[(s->top)--];
}

//스택은 여러 정점들중 진입차수가 0이 된 정점들에 대하여 저장하는 용도이다.

int topo_sort(GraphType* g) {
	int i;
	StackType s;
	GraphNode* node;

	//모든 정점의 진입 차수를 계산
	int* in_degree = (int*)malloc(g->n * sizeof(int)); //in_degree[] 에 대하여 여기에서는 인덱스에 맞춰서 정점번호가 매칭되거니와, 각 요소에는 진입차수를 입력한다.
	//정점 수 만큼 동적 할당 생성.
	for (i = 0; i < g->n; i++)
		in_degree[i] = 0; //우선 초기화
	for (i = 0; i < g->n; i++) {
		GraphNode* node = g->adj_list[i];
		while (node != NULL) {
			in_degree[node->vertex]++; 이곳에서 각 노드에 대하여, 간선수를 파악하기 위해 끝까지 노드를 순회
			node = node->link;  //순회를 하되, 말 그대로 '진입차수'를 봐야 하는 것이기에, 보고 있는 adj_list[i] 에 매칭되는 노드의 주위 간선을 세고 있는 것이 아닌, 각 주위 간선의 도착 정점의 수를 늘리는 것이다. 그래야 진입 차수를 보는 것이기에. 
		}
	}

	init(&s);   //스택 초기화
	for (i = 0; i < g->n; i++) {
		if (in_degree[i] == 0)
			push(&s, i);  //진입 차수가 0이라면 스택에 삽입한다.
	}
	//in_degree는 진입차수 저장. 스택 s는 진입차수가 0인 정점 저장.
	while (!is_empty(&s)) {
		int w;
		w = pop(&s);
		printf("정점 %d ->", w);
		node = g->adj_list[w]; //헤드 노드로 대입
		while (node != NULL) {
			int u = node->vertex; //진입차수가 0인 어떤 정점이 출력된 순간 그 정점은 거치게 된 것으로 치거니와, 사라진 거와 같이 생각하자. 그러면 그 정점에 있던 간선들도 사라지고, 그 간선들은 모두 각 끝 정점들의 진입 간선일 것이다.
			in_degree[u]--; //진입차수를 저장하고 있던 일차원 배열 in_degree에 대응 되는 u (정점)의 요소를 -1 시킨다.
			if (in_degree[u] == 0) //만약 그렇게 요소를 -1시켯는데 0 (진입차수가 0) 이라면?
				push(&s, u); //바로 그 정점도 스택에 넣는다.
			node = node->link; //다음 정점 조사

		}

	}
	free(in_degree);
	printf("\n");
	return (i == g->n);  //의문점: ...? i는 뭐가 되는가..? 다 함수내부에서 i가 쓰였을뿐.. 이게.. 아무 값도 대응이 안된 것 아닌가..? 동시에 반환값이 의미하는 것은 무슨..?
//436p 교재에 나오는 구현이 조금 잘못 되었다. 모든 정점을 위상 정렬로 나열할 수 있으면 성공(1) 중간에 막히면 실패(0) 의 의도이며, 이렇게 비교하는 것이 맞다. pop의 횟수. 혹은 정점 출력수.

/*while (!is_empty(&s)) {
		int w;
		w = pop(&s);
		printf("정점 %d ->", w);
    count++; //이런 식으로 고쳐 써주자. int count라는 변수도 미리 선언하고. 그리고 마지막에 return (count == g->n) 이렇게 하자.
}
*/

int main() {
	GraphType g;

	graph_init(&g);
	insert_vertex(&g, 0);
	insert_vertex(&g, 1);
	insert_vertex(&g, 2);
	insert_vertex(&g, 3);
	insert_vertex(&g, 4);
	insert_vertex(&g, 5);
	

	insert_edge(&g, 0, 2);
	insert_edge(&g, 0, 3);
	insert_edge(&g, 1, 3);
	insert_edge(&g, 1, 4);
	insert_edge(&g, 2, 3);
	insert_edge(&g, 2, 5);
	insert_edge(&g, 3, 5);
	insert_edge(&g, 4, 5);

	topo_sort(&g);

	return 0;
}
