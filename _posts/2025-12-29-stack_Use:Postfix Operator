인간이 활용하는 연산은 1+2 과 같은 중위표기법이나, 컴파일러는 우선순위 규칙, 괄호 등의 규칙을 없애기 위하여 후위표기법을 사용한다.
후위 표기식에서의 규칙 자체는 간단하다. 연산자가 항상 두 피연산자 뒤에 와야 한다. 
예를 들어 1+2 를 12+ 으로 써야하고, 3+4*5 는 345*+ 으로 쓴다.

이를 이제 스택으로 표기할 것이다. 기본적으로는, 수식을 왼쪽에서 오른쪽으로 스캔하여, 피연산자 라면 스택 요소에 넣고, 연산자라면, 스택에서 피연산자를 꺼내, 연산한뒤 그 결과값을 다시, 스택에 넣는다.
예시를 더 들어보자. 82/3-32*+ 이다.
왼쪽부터 순서대로 스캔할때, 스택에 8저장 -> 스택에 2저장-> 연산자 '/' 만남, 8과 2를 pop시키고 연산, 결과값 4을 스택에 저장.(스택에는 4만 남게 된다) ->스택에 3저장 -> '-'연산자 만남, 4와 3을 pop시키고 연산, 결과값 1을 스택에 저장.
->스택에 3 저장 ->스택에 2저장 -> '*' 연산 만남. 후입 선출로 3과 2 연산, 6반환 스택 저장. -> '+' 만남. 1과 6을 연산, 최종적으로 결과값 7 스택에 저장.
//pop으로 먼저 스택에서 나오는 값이 오른쪽 피연산자가 된다/


#include <stdio.h>
#include <stdlib.h>
#define MAX_STACK_SIZE 100

typedef int element;
---스택 구현 -- 
int eval(char exp[]) {
	int op1, op2, value, i = 0;
	int len = strlen(exp);
	char ch;
	StackType s;

	init_stack(&s);
	for (i = 0; i < len; i++) {
		ch = exp[i];
		if (ch != '+' && ch != '-' && ch != '*' && ch != '/') {
			value = ch - '0';   //예를 들어서 '8' - '0' = 56 - 48 = 8 이렇게 정수로 된다. C언어는 문자 숫자와, 숫자가 다르다. 
			//그러나, for문에 대해서 한자리 수 씩 계산이 된다. 예컨대, (13 9+) 이와 같은 간단한 연산도, 잘못 해석하게 된다.
			push(&s, value);
		}
		else {
			op2 = pop(&s); 
			op1 = pop(&s); //연산자를 만날 경우 else실행, 이후 스택에서 두 피연산자를 꺼내온 후 (pop으로 동시에 반환값 대입)
			switch (ch) {
			case '+': push(&s, op1 + op2); break;//연산을 진행한 후, 결과값 만을 스택에 다시 넣는다.
			case '-': push(&s, op1 - op2); break;
			case '*': push(&s, op1 * op2); break;
			case '/': push(&s, op1 / op2); break;
			}
		}
	}
	return pop(&s);
}

int main() {
	int result;
	printf("후위표기식은 82/3-32*\n");
	result = eval("82/3-32*+");
	printf("결과값은 %d\n", result);
	return 0;
}
이 코드는, 후위표기수식으로 이미 표기된 식을 계산하는 것이다. 동시에, 한 문자씩 검사하기에, 두 자릿수 이상의 연산은 제대로 되지 않는다.

-----------------------

하지만 사용자가 사용하는 식은 중위표기수식이다. 그렇기에 중위표기수식을 후위표기수식으로 변환하는 프로그램 코드도 작성해야 한다.
우선 중위표기법과 후위표기법의 공통점은 피연산자의 순서가 동일한다는 것이다.
그렇기에 우선 왼쪽에서 오른쪽으로 차례대로 스캔하는 것은 같다. 하지만, 변환하기 위해서는, 피 연산자는 만난다면 후위연산자에 출력하고, 연산자를 만난다면 잠시 보류해야 한다.
후위표기수식은 연산자가 피연산자들 뒤에 있는 것이 기본적인 규칙이다.
예컨데, a+b*c 가 있다고 하자, 그럼 중위표기수식에서 후위표기수식으로 변환하여 출력하면, abc*+ 으로 (연산자가 스택에 저장된다는 것을 고려, 후입선출의 근거로) 맞다.
하지만 a*b+c 가 있다고 하자. 이것 또한 그냥 한번에 쌓여놓고 pop시키면 안된다. 한다고 치면, abc+* 인데, 이걸 중위표기수식으로 보면 a*(b+c) 으로 아예 다른 식이 되버리기 때문이다.
즉, 이런 규칙으로 보는게 맞다. 스택에 이미 있던 연산자가, 현재 스캔을 하고 있는 연산자보다 우선순위가 높거나, 같다면, 쌓는것이 아닌, 스택에 이미있던 연산자를 출력하고, 현재 스캔 연산자를 스택에 넣는거다.
다시보자.  a*b+c에서 a*b 까지 해서 ab 출력, *는 스택에 있는 상황이다. 이후 +를 만났으나, *가 +보다 우선순위가 높다. 그렇기에 *는 pop되어 출력, 그 이후에야 +는 스택에 저장된다. 이후 나머지를 하면.
ab*c+가 된다.
괄호연산자의 경우, 왼쪽 괄호의 경우, 우선순위가 가장 낮은 연산자로 취급하여, 다음에 만나는 연산자는 어떤 연산자이든 쌓이게 한다. 이후, 오른쪽 괄호를 만날시, 자신은 사라지며, 자신의 위에 쌓여있는 연산자들을 한번에 출력한다.
예를 들어보자. (a+b)*c 가 있다. 스택'(' 저장 -> a출력 -> 스택 + -> b출력 -> 오른쪽 괄호 ) 만남, 자신 위의 +를 출력하고, 스택의 괄호는 사라짐. : ab+ -> *만남 스택에 저장 -> c출력. 
그러면 결과로 ab+c* 가 된다.

이제 코드를 본다.
#include <stdio.h>
#include <stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;
-----스택 구현부분-----


int prec(char op) {
	switch (op) {
	case '(': case ')': return 0;
	case '+': case '-': return 1;
	case '*': case '/': return 2;   //리턴 반환 값에 우선순위가 높을 수록 큰 값이 반환되도록 하였다.
	}
	return -1; 
}

void infix_to_postfix(char exp[]) {
	int i = 0;
	char ch, top_op;
	int len = strlen(exp);
	StackType s;

	init_stack(&s);
	for (i = 0; i < len; i++) {
		ch = exp[i];
		switch (ch) {
		case '+': case '-':case '*': case '/':
			while (!is_empty(&s) && (prec(ch) <= prec(peek(&s)))) //만약 스택에 현재 있는 (peek으로 알아냄) 연산자 우선순위 (반환값) 이 현재 보는 연산자 보다 같거나 클 경우.
				printf("%c", pop(&s)); //스택에 있는 연산자는 출력한다.
			push(&s, ch); //그러고 나서 현재 스캔중인 연산자를 스택에 저장.
			break;

		case '(':
			push(&s, ch); //우선 (를 스택 안에 넣는다.
			break;
		// 이 코드에서도 보였다시피, 물론 우선순위를 제일 낮게본다고 설명할때는 그리 하였으나, 실제로는 '('를 만나면 우선순위 비교를 ')'를 만날때까지 멈춘다. 즉 원래 스택에 있던 연산자와 '('를 비교하지도 않는다.

		case ')':
			top_op = pop(&s); //우선 바로 스택에 있는 것 중 제일 위에 있는것을 pop시킨 후 반환값으로 저장.
			while (top_op != '(') { //오른쪽 괄호를 읽을 경우, 스택에서 왼쪽 괄호가 나올때까지, 
				printf("%c", top_op);
				top_op = pop(&s); //위에 쌓인 연산자들을 모두 계속 출력하고 pop시킨다.
			}
			break;  //의문점: '(' 는 스택에서 pop이 되는 것인가..?  //된다. 예를 들어보자. (a+b) 으로 간단히 보면, ( 스택 저장 -> a출력 -> '+' 스택저장 -> b출력 -> ')' 만남. 이 코드가 실행됨.
			//바로 스택의 가장 위에 있던 +가 top_op가 되고, 출력이 된다. 이후 마지막으로 top_op = pop(&s); 의해 (는 pop만 되고, 조건문에 걸려 출력이 되지도 않는다.

		default: //이 경우는 연산자가 아닌 피연산자인 경우를 뜻한다.
			printf("%c", ch);
			break;
		}
		

	}
	while (!is_empty(&s))
		printf("%c", pop(&s));//수식의 끝까지 갔으므로, 이제 스택안에 있는 연산자들을 후입 선출 스택으로 모두 출력해야 한다. 
}
	int main() {
		char* s = "(2+3)*4+9";
		printf("중위표시수식 %s \n", s);
		printf("후위표시수식 ");
		infix_to_postfix(s);
		printf("\n");
		return 0;
	}


