시스템 스택(System Stack): 컴퓨터 프로그램이 함수를 호출하고 복귀할 때 실행 순서를 관리하기 위해 사용하는 메모리 영역

어떠한 함수든 간에, 함수가 호출된다면, 이 시스템 스택에 
복귀 주소가 저장되고. 매개변수, 지역변수를 할당한다.
즉 중요한 것은 스택의 특징은
: 계속 쌓여나감, 빠질땐 마지막으로 쌓인 것 부터, 순서대로 빠져나감.
이므로 
int factorial(int n){
  if (n<=1) return(1);
  else return (n * factorial(n-1));
}
에서 만약 n = 3 을 대입하였다고 치면, 
factorial(3) -> factorial(2) -> factorial(1) 이렇게 호출되지만.
함수가 끝난다면, 스택의 규칙대로 반대로 factorial(1) 부터 factorial(3) (복귀주소로 통하여) 으로 간다. 

이때, 매 호출마다 C언어는 지역변수가 시스템스택에 계속 독립적으로 새롭게 할당되어 지기 때문에 순환호출이 가능하다. 
COBOL 과 같은 고전적 언어는 불가능하다.

int factorial(int n){
  printf("factorial(%d)\n",n);
  if(n<=1)return(1);
  else return(n * factorial(n-1));
}

이런 경우에는 printf문은 마주치자마자, 실행 되기에 factorial(3) 부터 (1) 까지 순서대로 출력된다.

int factorial(int n){
    if(n <= 0) return 1;
    int result = n * factorial(n-1);
    printf("factorial(%d)\n", n);   
    return result;
} 

이 코드를 보면 재귀 함수 호출 이후에 printf문이 있다. 
즉 이 코드를 실행하면, 의도대로 factorial(1) 부터 factorial(3)까지 순서대로 출력된다.
이를 후입선출법, 스택의 성질인 LIFO 라고도 부른다.

---------------------------------------------------------------------------------------
X의 거듭제곱 계산
대부분 반복과 순환은 서로 바꾸어 쓸수 있지만, 순환은 이해하기 쉬운 반면, 반복보다 일반적으로 시간복잡도가 더 느리다는 단점이 있다.

double power(double x, int n){
    if (n==0)return 1;
    else if ((n%2) == 0)
        return power(x*x, n/2);
    else return x*power (x*x, (n-1)/2));
}
이 코드에서는 x와 n 을 매개변수로 잡는다. 만약 n=0 일 경우 그냥 1을 반환한다.
이후에 n에 대해서 짝수 인지, 홀수인지를 보는데, 여기서 우리가 계산할 결과는 x의 n승이다.
n%2 == 0 즉 짝수일 경우에는, 
x*x 와 n/2 시킨 변수로 바꾼뒤, 재귀호출을 한다.
이는 x^2 를 매번 빼놓는 것으로 예컨데, 9^4 을 구하고자, x = 3, n = 6 를 넣으면, (3^2)^3 으로, 즉 9^3 x=9, n=3으로 재귀 호출을 한다.

두번 째 경우는 else 으로 n이 홀수인 경우로, 이의 경우에는, 앞에서의 9^3 이라고 쳣을때, 
9*9^2 로 우선 x인 9를 하나 때어낸뒤, 이후 짝수때와 같이 x는 제곱을, n은 x를 하나뺏으니 1을 먼저 뺸후 2로 나눈다.

//이때의 반복 횟수는 계속 /2 로 줄어드므로 O(log n) 이다. 

이는 

double power(double x, int n){
  int i;
  double result = 1.0;  
  for(i=0; i<n; i++)
    result = result * x;
  return(result);
}

의 단순 반복 코드와 비교하였을때, 이 반복은 O(n) 시간 복잡도로, 즉 x^n 을 구하는 함수에서는 예외적으로 순환이 반복보다 더 효율적이다.
------------------------------------------------------------------------------------------------------------------------
피보나치 수열

순환으로 할 경우에는 
int fib(int n){
  if(n==0) return 0;
  if(n==1) return 1;
  return (fib(n-1)+fib(n-2));
}

저 코드는 매우 간단하지만, 시간 복잡도는 O(2^n) 으로 매우 비효율적이다.
왜냐하면 만약, n = 8 을 넣는다고 하자. 
그러면 fib(7) 과 fib (6) 을 또 저 둘은 각각 fib(6),fib(5)//fib(5),fib(4) 그리고 저 넷은 또 각각, 2개씩, 그렇게 8개가 호출, 또 2개씩, 16개... 이런식으로 진행이 되기 떄문이다.
즉 이 경우에는 일반적인 반복 코드가 훨씬 낫다.

int fib(int n){
  if (n==0) return 0;
  if (n==1) return 1;
 
  int pp = 0;     //피보나치의 일부 0 1 1 2 만 보더라도 이해된다.
  int p = 1;
  int result = 0;

  for (int 2 =0; i<=n; i++){
    result = p + pp; //result 는 단계로 봤을때, 구하고자 하던 값인 0 + 1
    pp = p;  //이후 결과를 저장한뒤, pp는 한칸 뒤로 1이 되기 위해, 위치상으로 p대입
    p = result; // 마찬가지로 p의 경우에도 위치상으로 result 대입.
  }
  return result;
}
