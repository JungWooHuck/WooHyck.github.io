/*
- 이차 조사법 - 

이차 조사법은 선형 조사법과 매우 유사하다. 하지만, 바로 다음 인덱스가 아닌, 다음 조사할 위치의 인덱스를 이 식으로 결정한다.
(h(k) + inc * inc) mod M for inc = 0,1 ..., M-1

쉽게 보면 이거다. 선형 조사법은 h(k) + 1, h(k) + 2, h(k) + 3, ... 이런식으로 인덱스를 하나씩 늘려가며 조사하였었다 이차 조사법은 이거다.
h(k) + 1², h(k) + 2², h(k) + 3², ... 즉 제곱씩 곱한 값으로 증가하는 것이다. 

이제 코드를 보자.

void hash_qp_add(element item, element ht[]) {
	int i, hash_value, inc = 0;
	hash_value = i = hash_function(item.key);
	while (!empty(ht[i])) {
		if (equal(item, ht[i])) {
			fprintf("탐색키가 중복되었습니다\n");
			exit(1);
		}
		i = (hash_value + inc * inc) % TABLE_SIZE; //이렇게 다음으로 조사할 부분만 바꾸면 된다. 간단하다.
		inc = inc + 1;
		if (i == hash_value) {
			fprintf(stderr, "테이블이 가득찼습니다.\n");
			exit(1);
		}
	}
	ht[i] = item;
}
*/

/*
- 이중 해싱법 (double hashing, rehashing) - 
이는 이런 방법이다. 오버플로우가 만약 발생하였다면, 저장할 다음 위치를 결정할 때, 원래 해시 함수와 다른 별개의 해시 함수를 이용하는 것이다.
선형과 이차는 충돌이 발생할 경우에는 다음으로 조사할 인덱스를 어떠한 값을 더해서 다음 위치를 얻는다.

따라서 해시 함수값이 같다면 차후에 조사되는 위치도 같게된다. 즉 어떻게 보면 충돌이 자주 일어나게 되며, 해시 테이블에 상대적으로 균일하게 분포시킬 수 없게 된다.

이중 헤싱법에서는 키를 참조하여 더해지는 값이 결정된다. 따라서 해시 함수값이 같더라도 키가 다르면 서로 다른 조사 순서를 갖는다.
따라서 선형과 이차 방법과는 다르게 집중현상을 피할 수 있다.

두 번째 해시 함수는 조사 간격을 결정하게 된다. 일반적으로는 이렇다.
h'(k) = C - (k mod C)
이런 형태의 식은 (k mod C)이 0부터 C-1 까지 생성하므로 [1, C] 범위의 값을 생성하게 된다.
충돌이 발생하였을 경우에, 조사되는 위치는 이런식으로 된다. 보자.

h(k), h(k)+h'(k), h(k)+2*h'(k), h(k)+3*h'(k), ..

이때 C는 보통 테이블의 크기인 M보다 약간 작은 소수를 선택한다. 

이제 예시를 들어보면서 봐보자. 해시테이블의 크기는 7이고,  h(k) = k mod 7 이고, h'(k) = 5 - (k mod 5) 이다.
8, 1, 9, 6, 13의 탐색 키들이 삽입되는 경우다.

1) 8 mod 7 = 1 (저장)
2) 1 mod 7 = 1 (충돌) -> (h(1) + h'(1)) mod 7 = (1+5-(1 mod 5)) mod 7 = 5(저장)
3) 9 mod 7 = 2 (저장)
4) 6 mod 7 = 6 (저장)
5) 13 mod 7 = 6 (충돌) -> (h(13) + h'(13)) mod 7 = 1 (충돌) -> (h(13) + 2* h'(13)) mod 7 = (6+2*2) mod 7 = 3 (저장)


이렇게 된다. 5)의 경우를 보자. 규칙성이 있긴 하다. 2씩 늘어 난다는 것이다. 그리고 테이블의 마지막에 도달하면 처음으로 되돌아 가는 성질도 가지고 있다.
//의문점: 그렇다면.. 규칙성이 있으므로 이중 해싱법의 경우에도 편향 혹은 집중 문제가 완화되었을뿐 있는 것이 아닌가..?
//답: 아니다. 잘 보자. 선형과 이차는 초기 해시값이 있다면 무조건 똑같다. 다음 주사할 위치가 계속 말이다. 
반면에, 이중 해싱법은 물론 각 키 내부에서는 일정한 조사 간격을 가지는 것은 맞다. 하지만 다음 조사할 위치를 키값에 따라 다른 해쉬함수로 반영하여 고르기에, 거의 경로가 중복되지 않는다.

이제 코드를 보자.

void hash_dh_add(element item, element ht[]) {
	int i, hash_value, inc;
	hash_value = i = hash_function(item.key);
	inc = hash_function2(item.key); //미리 h'(k) 를 적용시킨 해싱함수 적용 값을 inc에 대입

	while (!empty(ht[i])) {
		if (equal(item, ht[i])) {
			fprintf(stderr, "탐색키가 중복되었습니다. \n");
			exit(1);
		}
		i = (i + inc) % TABLE_SIZE; // 원형구조 고려 및, 계속 inc가 더해진다는 규칙성 고려.
		if (i == hash_value) {
			fprintf(stderr, "테이블이 가득찼습니다.\n");
			exit(1);
		}

	}
	ht[i] = item;
}

이제 개방주소법으로 3가지를 봤다. 전체적으로 비교해보자.

선형 조사법: 
구현이 제일 간단하다. 연속적으로 +1 씩 인덱스를 하여 조사하기에, 캐쉬 친화적이다.
그러나 해쉬함수에 의해 같은 인덱스를 처음으로 배정받게되면 조사 경로가 모두 똑같게 된다. 충돌이 자주 일어난다.

이차 조사법:
선형에 비해서는 충돌이 완화 되었다.
그러나 2차 클러스터링이 발생한다. 또한 선형 조사법의 단점이 그대로 이어진다.

이중 해싱법:
경로 중복이 거의 없다. 또한 가장 해시 테이블에 균등하게 분포할 수 있도록 배치 할 수 있는 방법이다.
해쉬함수가 2개가 필요하고, 이에 따라, 해쉬함수 계산의 비용 복잡도 고려가 필요하다. 캐쉬 효율이 떨어진다.



그리고 개방주소법의 전체적인 장/단점은 이것이다.

- 해시 테이블이 하나의 배열로 표현될 수 있을 뿐더러, 추가 포인터나 동적 노드 할당이 필요없다.
- 배열 접근이기에 캐쉬 친화적이다.
- 구현이 단순하다.
- 크기가 작은 해쉬 테이블과 key의 수 일수록 더더욱 빨라진다.


- 한 번도 사용되지 않은 위치가 있어야만이 탐색이 빨리 끝난다. 만약 모든 위치가 사용되고 있거나 delete 위치라면 결국 테이블의 모든 위치를 순회하면서 조사하게 된다. 이럼 시간적으로 매우 비효율적이다.
- 삭제 구현이 복잡하다.
- 만약 해쉬테이블에 대부분이 이미 삽입된 상태라면  이후 삽입을 할 경우에, 충돌이 매우 많이 일어나게 된다.



*/

