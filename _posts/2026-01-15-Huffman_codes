//허프만 코드는 8비트를 이용하는 아스키코드와 달리, 전체 데이터의 양을 줄이기 위하여 고정된 길이를 사용하지 않고 가변 길이의 코드를 사용하며,
//각 글자의 나오는 빈도수에 따라서 가장 많이 등장하는 글자일수록 짧은 비트열을 사용하는 코드이다.  
//또한 가변코드의 특징을 생각하여, 분별이 불가능하지 않게 하기 위하여, 모든 비트열의 코드가 다른 코드의 첫 부분이 아니게 한다. 예컨데 01000010 이런 코드가 있다면, 01 만 있지, 010이나 0 과 같은 코드를 없게 하는 것이다.

//허프만 코드를 구현하기 위하여, 우선 빈도수를 기준으로 글자를 나열한후, 이 중 가장 적은 빈도수의 글자 2개를 추출하여 이들을 단말노드로 하여 이진 트리를 구성한다. 루트의 값은 자식 노드의 갓을 합친것으로 한다.
//다시 정렬된 글자들의 리스트로 돌아가서 이 합쳐진 값을 글자들의 리스트에 삽입한다. 이후에 이 빈도수를 다시 정렬하고, 이중에서 가장 작은 값 2개를 단말노드로 해서 다시 이진트리로 구성하고,.,,, 등을 한다. 
//그렇게 반복하여 최종적으로 마친후, 왼쪽 간선은 비트 1을 나타내고 오른쪽 간선을 비트 0을 나타내게 한다.

// 가장 작은 2개의 빈도수를 얻는 과정은 최소히프를 이용한다.


#include <stdio.h>
#include <stdlib.h>
#define MAX_ELEMENT 200

typedef struct TreeNode {
	int weight; //빈도수
	char ch; 
	struct TreeNode* left;
	struct TreeNode* right;
}TreeNode;

typedef struct {
	TreeNode* ptree; //TreeNode 노드 를 가르키는 하나의 포인터이다.
	char ch;
	int key; //빈도수
}element;

typedef struct {
	element heap[MAX_ELEMENT];
	int heap_size;
}HeapType;

HeapType* create() {
	return (HeapType*)malloc(sizeof(HeapType));
}

void init(HeapType* h) {
	h->heap_size = 0;
}

void insert_min_heap(HeapType* h, element item) {
	int i;
	i = ++(h->heap_size);

	while ((i != 1) && (item.key < h->heap[i / 2].key)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item;
}

element delete_min_heap(HeapType* h) {
	int parent, child;
	element item, temp;

	item = h->heap[1];
	temp = h->heap[(h->heap_size)--];
	parent = 1;
	child = 2;
	while (child <= h->heap_size) {
		if ((child < h->heap_size) && (h->heap[child].key) > h->heap[child + 1].key) 
			child++;
		if (temp.key < h->heap[child].key) break;

		h->heap[parent] = h->heap[child];
		parent = child;
		child *= 2;
	}
	h->heap[parent] = temp;
	return item;
}

TreeNode* make_tree(TreeNode* left, TreeNode* right) {
	TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
	node->left = left;
	node->right = right;
	return node;
}

void destroy_tree(TreeNode* root) {
	if (root == NULL) return;
	destroy_tree(root->left);
	destroy_tree(root->right);
	free(root);
}

int is_leaf(TreeNode* root) {
	return !(root->left) && !(root->right);  //둘다 NULL일 경우이다.
}

void print_array(int codes[], int n) {
	for (int i = 0; i < n; i++)
		printf("%d", codes[i]);
	printf("\n");
}

void print_codes(TreeNode* root, int codes[], int top) {

	//왼쪽 간선일 경우, 1을 저장하고 순환호출한다.
	if (root->left) {
		codes[top] = 1;
		print_codes(root->left, codes, top + 1);
	}
	//오른쪽은 0을 저장한다.
	if (root->right) {
		codes[top] = 0;
		print_codes(root->right, codes, top + 1);
	}

	if (is_leaf(root)) {
		//단말 노드라면 코드를 출력한다.
		printf("%c: ", root->ch);
		print_array(codes, top);
	}
}

void huffman_tree(int freq[], char ch_list[], int n) {
	int i;
	TreeNode* node, * x; //이진 트리
	HeapType* heap; //힙
	element e, e1, e2; //힙에 들어갈 요소
	int codes[100];
	int top = 0;

	heap = create();
	init(heap);
	for (i = 0; i < n; i++) {
		node = make_tree(NULL, NULL);
		e.ch = node->ch = ch_list[i]; //(아마도..?) 글자를 빈도수에 맞춰서 오름차순으로 정렬한 인덱스 대응 값을 node->ch 와 e.ch 에 저장한다.
		e.key = node->weight = freq[i]; //freq는 빈도수 자체를 표현한 배열이다. weight 는 빈도수로 우선순위를 결정하는 주요한 값이다.
		e.ptree = node; //이후에 ptree에는 노드를 대입시킨다.
		insert_min_heap(heap, e);//이후 히프에도 삽입한다.
	} //이렇게 반복문을 실행하여 우선 왼쪽과 오른쪽 링크가 NULL로 모두 되어있는 
	//힙는 ch,  key, ptree 으로 이루어져 있고  (각 element가) TreeNode 는 weight, ch, 링크필드로 이루어져 있다.
	//우선 TreeNode의 단일 노드를 하나씩 계속 생성한다. 그리고 힙의 ch와 노드의 ch는 같은 값으로 글자를 표현하고, 히프의 key와 노드의 weight는 같은 값으로 글자의 빈도 수를 의미한다.
	//그리고 히프에는 삽입한다.

	for (i = 1; i < n; i++) {
		//최소값을 가지는 두개의 노드를 삭제한다.
		e1 = delete_min_heap(heap); //최소히프에 맞춰서 루트에 있는 값을 빼내고 히프를 다시 제대로 배치시킨다.
		e2 = delete_min_heap(heap);

		x = make_tree(e1.ptree, e2.ptree); //각 왼쪽 오른쪽 링크필드(자식노드를 가르키는)가 e1.ptree, e2.ptree인 새로운 노드를 생성시킨다.
		e.key = x->weight = e1.key + e2.key; //이후 빈도수를 합친 것을 새로운 노드의 x에, 동시에  e의 key에 새로 넣은 후, 
		e.ptree = x; //그 e에 x의 노드를 대입시킨뒤
		printf("%d+%d->%d \n", e1.key, e2.key, e.key);
		insert_min_heap(heap, e); //힙에는 그 e를 새롭게 넣는다.
	}

	e = delete_min_heap(heap); //남은 하나는 지운다.
	print_codes(e.ptree, codes, top);
	destroy_tree(e.ptree); //맨 마지막으로 대입되었던 e.ptree 는 트리의 투르와 같다.    
	free(heap);  
}

int main() {
	char ch_list[] = { 's', 'i', 'n', 't', 'e' };
	int freq[] = { 4,6,8,12,15 };
	huffman_tree(freq, ch_list, 5);
	return 0;
}
