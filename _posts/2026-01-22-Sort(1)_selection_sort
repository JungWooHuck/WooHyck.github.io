//일반적으로 보통 정렬시켜야 될 대상을 레코드라고 부른다. 그리고 레코드는 다시 필드라고 하는단위로 나누어진다. 이 중에서 레코드와 레코드를 분별해주는 역할을 하는 핵심 필드를 '키' 라고 한다.
//즉 정렬은 레코드들을 '키'의 기준에 맞춰서 재배열하는 것이다.
//정렬 알고리즘에서 효율성의 기준은, 정렬을 위해 필요한 비교 연산의 횟수, 이동 연산의 횟수 이렇게 두 가지이다.
//정렬 알고리즘은 크게 2가지로 나누어 질 수 있다. 단순하지만 비효율적인 방법(삽입, 선택, 버블)과 복잡하지만 효율적인 방법(퀵, 히프, 합병, 기수) 
//혹은 안정성에 있어서도 분류할 수 있다. 예컨대 같은 키 값을 가지는 레코드가 여러개 존재할 경우, 이들 레코드들의 상대적인 위치가 정렬후에도 바뀌지 않는 것이 안정성이다. 이는 삽입, 버블, 합병 정렬이 있다.


//선택정렬: 알고리즘 자체는 간단하다. 입력 배열에서 최소값을 발견한 다음에, 그 최소값을 배열의 첫번째 요소와 교환한다. 
//다음에는 첫번째 요소를 제외한 나머지 요소들 중에서 가장 작은 값을 선택하고 두번째 요소와 교환한다. 이를 반복한다.

#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 10
#define SWAP(x,y,t) ( (t)=(x), (x)=(y), (y)=(t))  //교환


int list[MAX_SIZE];
int n;

void selection_sort(int list[], int n) {
	int i, j, least, temp;
	for (i = 0; i < n - 1; i++) { //이때 인덱스의 끝까지 반복은은 하지 않는다. 마지막 한 요소는 자동으로 가장 큰 값이 되기에.
		least = i;  //least는 0번째 인덱스 부터 시작.
		for (j = i + 1; j < n; j++) //최소값 탐색
			if (list[j] < list[least])
				least = j;
		SWAP(list[i], list[least], temp); //찾은 최솟값 인덱스 least와 (첫 반복 기준) 첫번째 인덱스 [0]의 요소를 바꾼다.
	}
}

int main() {
	int i;
	n = MAX_SIZE;
	srand(time(NULL)); //시드 설정. NULL으로 함으로써 매 초마다 바뀌어짐.
	for (i = 0; i < n; i++) //난수 생성
		list[i] = rand() % 100; //항상 a으로 나눈 나머지 값은 0부터 a-1 의 범위이다.  0~99 난수 생성

	selection_sort(list, n);
	for (i = 0; i < n; i++)
		printf("%d ", list[i]);
	printf("\n");
	return 0;
	
}

//자 이제 성능을 분석해보자. 앞에서 서술 하듯이 비교횟수와 이동횟수를 구해야 한다. 

//비교횟수는 for루프를 보자. 외부의 루프는 n-1 번 이고, 내부루프는 0 에서 n-2 까지 변하는 i (외부루프를 보자 for (i = 0; i < n - 1; i++)이다) 에 대하여 (n-1)-i 번 반복될 것이다.  

//키 값들의 비교는 내부 루프 안에서 이루어지므로 전체 비교횟수는 이와 같다.
//(n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n^2) 이다.     (그냥 단순 시그마 공식)

//이어서 교환 횟수를 보자. 레코드의 교환 횟수는 외부 for문 횟수와 같거니와, 한번의 교환에 있어서 3번의 이동이 필요하므로, 전체 이동 횟수는 3(n-1) 이 된다.


//선택 정렬의 장점은 자료 이동횟수가 미리 결정 된다는 점이다. 그러나 이동 횟수가 상당히 큰 편이며, 이미 자료가 어느정도 정렬된 경우에는 불필요하게 자기 자신과의 이동을 하게 된다.
//...물론 위의 단점도 이렇게 보충하면 된다. 
// if (i != least) SWAP(list[i], list[least], temp) 으로 말이다. 이러면 이미 자기자신이 그 남은 요소들중 최솟값인 경우에는 이동을 넘어가게 될 것이여여서 그나마 효율적이게 된다. 
