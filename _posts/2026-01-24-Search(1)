
//탐색
//탐색의 단위는 항목이다. 항목은 가장 간단하게는 숫자일 수도 있고 구조체가 될 수도 있다. 항목 안에는 항목과 항목을 구별시켜주는 탐색키가 있다.

//1. 정렬되지 않은 배열에서의 탐색
// 순차 탐색

//순차 탐색은 정렬되지 않은 배열의 항목들을 처음부터 마지막까지 하나씩 검사하여 원하는 항목을 찾아가는 방법이다. 함수는 이와같다.

int list[100];

int seq_search(int key, int low, int high) {//탐색의 범위는 low부터 high
	int i;

	for (i = low; i < high; i++)
		if (list[i] == key) //탐색에 성공하면 키 값의 인덱스 반환. 실패하면 -1 반환
			return i;
	return -1;
}

//위의 함수에서 비교횟수를 줄이는 방법을 생각해보자.
//리스트 전체를 탐색하기 위한 반복문에서 리스트의 끝을 테스트하는 비교연산이 있고 반복문 안에 키 값의 비교 연산이 있다.
//리스트의 끝을 테스트하는 비교연산을 줄이기 위해 리스트의 끝에 찾고자 하는 키 값을 저장하고, 반복문의 탈출조건을 키 값을 찾을 때까지로 설정한다.

int seq_search2(int key, int low, int high) {
	int i;

	list[high + 1] = key;
	for (i = low; list[i] != key; i++) //키 값을 찾으면 종료
		;
	if (i == (high + 1)) return -1; //탐색 실패
	else return 1;
}

//의문점: ...저게 처음 순차탐색보다 정말로 효율적인 코드인가..?
//답: 그렇다 제대로 봐보자. seq_search는  반복 1회마다 i<high 인지와 list[i] == key 이렇게 두번을 비교가 필요하다.
//하지만 seq_search2에서는 for 조건문 list[i] != key; 의 키 비교만 있다.
//두번째의 경우에는 저렇게 실제로 배열에 key가 없다고 하더라도, 배열의 끝에 key를 넣어서 비교 횟수를 절반으로 줄이게 한 것이다.

//2. 정렬된 배열에서의 탐색


/* -이진탐색 - */
//정렬되어 있지 않은 배열의 순차탐색은 구현하기가 쉽다. 하지만 만약 배열이 과도하게 많은 항목을 가지고 있는 경우에는 순차 탐색은 매우 비효율적이게 된다.
//먼저 정렬된 배열에서의 이진 탐색을 보자.

//이진 탐색은 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄인다.
//이런식으로 매 단계에서 리스트의 크기를 반씩 줄이면서 탐색하는 것이 이진탐색이다. 예를 들어보자. 10억개의 정렬된 항목이 있는 배열에서 이진탐색을 이용하여 특정 항목을 찾기 위해서면 30번의 비교만으로 검색이 완료된다.
//반면에 순차 탐색에서는 평균 5억 번의 비교가 있어야 한다.

//물론 이진탐색을 하기 위해서는 배열이 반드시 정렬되어 있어야 한다. 따라서 데이터의 삽입이나 삭제가 빈번할 시에는 적합하지 않고, 주로 고정된 데이터들의 탐색에는 매우 적합하다.
//이제 함수를 보자.

int search_binary(int key, int low, int high) { //순환 호출 이용
	int middle;

	if (low <= high) {
		middle = (low + high) / 2;
		if (key == list[middle]) //탐색 성공. middle은 배열 데이터중 중간 인덱스
			return middle;
		else if (key < list[middle]) //만약 그 중앙값보다 key가 더 작다면
			return search_binary(key, low, middle - 1); //중앙값 기준 왼쪽에 있는 부분 배열들에 대하여, 범위를 (low, middle-1) 으로 설정한뒤, 순환호출한다.
		else
			return search_binary(key, middle + 1, high);  //반대 경우. 오른쪽 부분 배열 탐색
	}
	return -1;  //탐색범위가 1보다 작아지는 if 조건문에 따라서 나오게 된다면. 탐색 실패
}

int search_binary2(int key, int low, int high) {
	int middle;

	while (low <= high) {
		middle = (low + high) / 2;
		if (key == list[middle])
			return middle;
		else if (key > list)
			low = middle + 1;  //반복하여 실행될것이기 위해, 오른쪽 범위에 있다면 low 인덱스만 바꿔주면 된다.
		else
			high = middle - 1; 

	}
	return -1;
}
//이진 탐색은 탐색을 반복할 때마다 탐색 범위를 반씩 줄어들게 하므로 시간 복잡도는 O(log n) 이다.


/* 색인 순차 탐색 */

// 색인 순차 탐색은 인덱스라 불리는 테이블을 사용한다.
// 이렇게 생각하자. 인덱스 테이블은 본래 자료가 전체적으로 있는 배열에서 일정한 적당한 간격으로 발췌한 것이다. 주 자료 리스트의 데이터 수가 n이고, 인덱스 테이블레 m개의 항목이 있다면
// 각 인덱스 항목은 주 자료 리스트의 각  n/m 번째 데이터를 가지고 있다.
// 자 그럼 생각해보자. 원하는 항목을 탐색하고자 할때, 이러면 된다. 먼저 바로 인덱스 테이블에서 index[i] <= key < index[i+1] 을 만족하는 것을 찾는다. 이후에는 그 구간 범위에서 주자료테이블로 다시 돌아가 순차 탐색을 하면 된다.
// 코드를 보자.

#define INDEX_SIZE 256
typedef struct {
	int key;
	int index;
}itable; //인덱스 테이블을 이런 구조체로 구현한다.
itable index_list[INDEX_SIZE];

int search_index(int key, int n) {
	int i, low, high;

	if (key<list[0] || key>list[n - 1])
		return -1;
	//키 값이 리스트의 범위내의 값이 아니면 탐색 종료

	for (i = 0; i < INDEX_SIZE; i++)
		if (index_list[i].key <= key && index_list[i + 1].key > key)
			//인덱스 테이블을 계속 순회하여 조사하면서 key가 어느 범위에 있는지를 조사한다.
			break;
	if (i == INDEX_SIZE) { //i가 만약에 인덱스 테이블의 범위 끝이라면 
		low = index_list[i - 1].index;  
		high = n;
	}
	else {
		low = index_list[i].index;
		high = index_list[i + 1].index;
	}
	//그렇게 low와 high의 범위를 설정한뒤에, 그 범위에만 순차탐색 진행한다.
	return seq_search(key, low, high);
}

//색인 순차 탐색 알고리즘의 탐색 성능은 인덱스 테이블의 크기에 따라 달라진다.
//인덱스 테이블의 크기를 m이라 하고, 주자료 테이블의 크기를 n이라고 하면, 복잡도는 O(m+n/m) 와 같다.


/* 보간 탐색 */
//보간탐색은 사전을 탐색하는 방법과 비슷하다. 예컨대 'z' 로 시작하는 단어를 찾으려 할때는 우리는 뒷부분부터 사전을 펼치는 것과 같다.
//이진 탐색과 유사하나, 리스트를 반으로 분할하지않고, 불균등하게 분할하여 탐색하다.

//탐색위치를 이렇게 한다. 봐보자. k는 찾고자 하는 키의 값, low와 high는 각각 탐색할 범위의 최소, 최대 인덱스다. 
//공식은 이러하다. 
//단 값과 위치는 비례한다는 가정에서 성립된다. 그러기 위해선 우선 배열이 정렬되어야 하며, 값들이 거의 균등하게 분포해야 한다.
//탐색위치 = {(k-list[low])/(list[high] - list[low])} * (high-low) + low

//보자 {(k-list[low])/(list[high] - list[low])} 는 전체 리스트 범위(list[high] - list[low]) 에서 어느 정도 위치에 있는지를 보여주는 것이다.
// 예컨대 0에 가까울 수록 맨 앞에 있다는, 1에 가까울수록 거의 뒤에 있다는 위치로 해석이 가능하다.
//이제 이 수치에 (high-low) 라는 전체 인덱스 길이를 더하거니와, 범위의 시작점이 무조건 0이 아닐수 있기에 low를 추가로 더한다.

//함수를 이제 보자. 추가로 구현하는 것은 이거다. 값이 대부분이 실수형태로 나오기에, 소수점을 버리는 연산이 필요하다.

int interpol_search(int key, int n) {
	int low, high, j;

	low = 0;
	high = n - 1;
	while ((list[high] >= key) && (key > list[low])) { //key가 계속 범위 내에 존재하는 동안만 반복.
		j = ((float)(key - list[low]) / list[high] - list[low]) * (high - low) + low;
		//float형 캐스팅을 주의하자. 하지 않을 경우 정수로 나눗셈이 계산되어 항상 0이 된다.
		//여기서 j는 보간공식으로 계산한 마치 'key' 가 있을 것 같을 인덱스 위치이다.
		if (key > list[j]) low = j + 1; //key값이 보간공식으로 구한 그 인덱스 보다 클경우. key는 j인덱스의 오른쪽에 존재하겠지.
		//그렇기에 low를 j+1으로 설정한다.
		else if (key < list[j]) high = j - 1;
		else low = j;
	}

	if (list[low] == key) return(low); //탐색 성공
	else return -1;

}

//다시 강조하지만 중요하다. 전제가 이리 되어야 한다. '반드시 정렬되어야 한다' , '되도록 값이 균등하게 분포되어야 한다'
//저 전제에 있어서는 복잡도는 이진 탐색과 비슷하게 O(log n)이 된다.

//의문점: 이진탐색과 복잡도는 O(log n) 으로 비슷해 보이는데.. 이 보간 탐색을 써야하는 이유가 무엇인가?
//보간탐색은 말 그대로 값이 균등하게 분포되어야 한다는 조건이 추가로 필요하지 않는가..?

//답: 우선 보간 탐색은 보간 계산으로 인하여 j를 먼저 유추한다는 것으로, 만약 저 전제가 제대로 되어 있는 조건이라면,
//이진 탐색보다 탐색이 더 빠를 것이다. 왜냐하면 찾고자 하는 key의 위치를 예측하여 근처 혹은 그 위치로 가기 때문이다.
//물론 배열이 (1, 2, 3, 4, 5, 6, 7, 1000000) 이런식으로 나열되어 있다고 치자. 그러면 보간 탐색을 쓰는것이 오히려 비효율적이다.
// 저렇게 값이 불균포되게 치우쳐져 있다면 복잡도는 O(n)이 된다.
