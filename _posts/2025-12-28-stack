#include <stdio.h>
#include <stdlib.h>

#define MAX_STACK_SIZE 100

//1차원 배열과 top변수를 모두 전역 변수로 구현하였다. 전역 변수로 구현하였기에, 배열이나 top변수를 함수의 매개변수로 전달하지 않아도 된다.
typedef int element;//직관적으로 보이기 위해, 타입 별칭
element stack[MAX_STACK_SIZE]; 
int top = -1; //top은 스택에 있어서의 가르키는 인덱스다. 동시에 0이 아닌 이유는, 0을 가르키는 순간 배열의 첫번째 인덱스에 데이터가 있다는 뜻이 되기 때문이다.
//push연산은 기본적으로 top을 +1 한 후 요소를 넣고, pop연산은 요소를 뺀 후 top을 -1한다. 순서차이가 있다.

int is_empty() {
	return (top == -1);
}

int is_full() {
	return (top == (MAX_STACK_SIZE - 1));
}
//두 함수의 경우, 항상 스택 연산을 하기전 확인해야 한다. 스택이 아예 비어있을 때 pop() 연산을 하면 에러가, 반대로 스택이 꽉 차있는데, push를 하면 에러가 나기 때문이다.

void push(element item) {
	if (is_full()) {
		fprintf(stderr, "스택 포화 에러\n"); //표준 에러 스트림에 출력
		return;
	}
	else stack[++top] = item; //전위 연산자로, 우선 top증가 이후 대입
}

element pop() { //pop() 의 경우, 삭제와 동시에, 그 삭제한 값을 가져온다. 즉 반환값을 element으로 설정한다.
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);  
	}
	else return stack[top--]; //이때 삭제는 따로 하지 않아도 된다. 스택은 후입선출 방식이기에, top이 가르키는 인덱스가 곧, 현재 있는 스택의 마지막으로 들어온 요소라는 뜻이다. 
	//즉 실제 값은 남아 있으나, 하지만 top 범위 밖의 값은 스택에 존재하지 않는 것으로 간주하는거다.
}

element peek() { //pop() 이 삭제와 값을 가져온다고만 친다면, peek() 는 삭제시키지 않고 값만 가져온다.
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top]; //top의 움직임 없음 오로지 반환만.
}

int main() {
	push(1);
	push(2);
	push(3);
	printf("%d\n", pop());
	printf("%d\n", pop());
	printf("%d\n", pop());
	return 0; //출력은 맨 마지막으로 push한 3부터 1순서로 
}
