//쉘 정렬
//쉘 정렬은 삽입정렬에서 따온 것으로 방법이 다른 정렬이다.
//삽입 정렬을 다시 봐보자. 삽입 정렬의 최대 문제점은 요소들이 삽입될 때, 이웃한 위치로만 계속 이동하면서 비교하고 삽입된다는 것이다.
//즉 만약 1이라는 작은 숫자를 삽입한다고 치고, 이미 정렬된 부분이 엄청 많다고 가정하면, 그 수만큼을 엄청 많이 이동을 해야 할 것이다.
//이러한 문제점을 완화하기 위해 쉘 정렬이 있다. 쉘 정렬은 전체의 리스트를 한 번이 아닌 여러번에 거쳐서 정렬하게 된다. 
//대신에 먼저 정렬해야할 리스트를 일정한 기준에 따라 분류하여 연속적이지않은 여러개의 부분리스트를 만들고, 각 부분 리스트는 삽입 정렬을 이용해서 정렬한다.
//모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분리스트로 만들고 반복한다. 이를 부분리스트의 개수가 1이 될때 까지 말이다. 
//부분 리스트를 구성할때는 각 주어진 리스트의 k번째 요소를 추출하여 만든다. 이때 k는 간격 (gap) 이다.

// ...예시로 들어보자. (10,8,6,20,4,3,22,1,0,15,16) 이렇게 있다. 
//처음 간격은 n/2가 좋으면 계속 간격을 절반으로 줄이는 방식이 통용되고 있다.
//그럼 요소수는 11개로 간격 k = 5가 된다. 그럼 5번쨰 간격에 맞춰서 부분리스트가 생성되는 것이다. 예컨대 이렇게 말이다.
// (10, 3, 16), (8, 22), (6, 1),  (20, 0), (4, 15) 
// 이제 각 부분리스트에 있어서 삽입정렬을 한다. 그러면 (3,10,16), (8,22), (1,6), (0,22), (4,15) 이렇게 될 것이다. 이후 적용된 모든 부분리스트에 삽입정렬이 마친 뒤에의 전체 배열은
// (3,8,1,0,4,10,22,6,20,15,16) 이렇게 된다. 이제 간격이 또 n/2가 되어 k=3 (간격이 짝수일 경우 1을 더하는 것이 통계적으로 좋다) 이 된다.
// 반복하자.그럼 (3,0,22,15), (8,4,6,16), (1,10,20) 이렇게 되고 각각을 또 삽입정렬을 한다.
// 마지막은 k=1 이 되거니와 전체를 삽입정렬한다.



//gap만큼 떨어진 요소들을 삽입 정렬, 정렬의 범위는 first 부터 last
inc_insertion_sort(int list[], int first, int last, int gap) { //삽입 정렬 함수
	int i, j, key;
	for (i = first + gap; i <= last; i = i + gap) { //리스트의 끝까지 가거니와, 간격 범위에 맞춰서 
		key = list[i]; //key는 삽입할 요소. ..어떻게 보면 처음 반복에서는 그 부분 리스트의 두번째 요소가 되는 것이다.
		for (j = i - gap; j >= first && key < list[j]; j = j - gap) //first를 벗어나면 안되거니와, 동시에 본래 삽입 정렬처럼 key값이 비교 대상보다 크다면 반복을 정지한다. 
			list[j + gap] = list[j]; //조건식을 모두 통과할 경우에는 본래 있던 요소가 오른쪽으로 밀려난다. (부분 리스트에서 한칸, 즉 간격 만큼)
		list[j + gap] = key;
	}
}

void shell_sort(int list[], int n) { //n = size
	int i, gap;
	for (gap = n / 2; gap > 0; gap = gap / 2) {  //처음은 요소수의 절반, 계속 이내 매 반복마다 간격을 절반으로 그렇게 gap이 0이 되기 전까지 반복
		if ((gap % 2) == 0)
			gap++; //짝수라면 gap을 +1   //의문점: 통계적으로 짝수라면 +1하는것이 더 좋다는 것은.. 외우면 되겠다만.. 증명은 되었는가..?
		//답: 완벽히 증명은 안되었다. 실험적 결과로써 하는 것이다만..이런 추론도 있다. 만약 짝수가 나온다면 그 이후로 /2를 하면 계속 짝수 간격만 나오기에, 일부 원소들은 같은 부분 리스트에 엮일 일이 전혀 없게 된다.
		for (i = 0; i < gap; i++)
			inc_insertion_sort(list, i, n - 1, gap);   //계속 gap의 간격을 줄이고, 부분리스트를 늘리면서 삽입정렬을 실행.
	}
}



//장점은 이렇게 된다. 연속적이지 않은 부분리스트에서 자료의 교환이 일어나면 더 큰거리를 이용하게 되서, 교환되는 요소들이 일반 삽입 정렬보다는 최종 위치에 더 가까워질 가능성이 높다.
//삽입정렬을 여러번 하는 것으로 비효율적으로 보이지만, 자료의 이동에 있어서 기본 삽입정렬보다 효율적으로 되게 된다.
//실험적인 통계로, 셀 정렬의 시간 복잡도는 최악의 경우는 O(n^2) 이지만 평균적으로는 O(n^1.5) 로 나타나진다.    
//의문점: ...저게 진짜인가? 증명되었는가? 
//답: 증명되지 않았다. 실험적 통계적으로 저런 시간 복잡도가 나온다는 것이지, 수학적 증명은 없다.
