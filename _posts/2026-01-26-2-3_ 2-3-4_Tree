// 2-3 트리
// 차수가 2 또는 3인 노드를 가지는 트리로서, 즉 하나의 노드가 두개 또는 세개의 자식 노드를 가지는 것이다. 
//2-노드는 일반 이진 탐색 트리처럼 데이터와, 두개의 자식노드를 가진다. 반면에 3-노드는  2개의 데이터와, 3개의 자식노드를 가진다.
//왼쪽 서브트리에 있는 데이터들은 모두 데이터가 k1, k2 있다고 할때, k1보다 작은 값이고, 중간 서프트리에 있는 값들은 k1보다 크고 k2보다 작다. 오른쪽 데이터들은 k2보다 큰 값이다.

//우선 탐색 연산부터 보자.

/*
Tree23Node* tree23_search(Tree23Node* root, int key) {
	if (root == NULL)
		return FALSE;
	else if (key == root->data)
		return TRUE; //만약 루트의 데이터가 탐색키와 같다면 바로 TRUE 반환.
	else if (root->type == TWO_NODE) { //만약 루트의 데이터가 찾던 키와 다르고, 2-노드라면
		if (key < root->key) //키 값이 더 작다면
			return tree23_search(root->left, key); //왼쪽 자식 노드를 인자로, 순환호출
		else
			return tree23_search(root->right, key);

	}
	else {
		//3-노드
		if (key < root->key1) //키가 root의 key1 이라는 데이터보다 작다면
			return tree23_search(root->left, key); //왼쪽으로
		else if (key > root->key2) //반대라면 오른쪽으로
			return tree23_search(root->right, key);
		else
			return tree23_search(root->middle, key); //둘다 아닌, 즉 key1보다 크지만 key2보다는 작을 경우에는 중간 서브트리로.

	}
		
}
*/

// - 삽입연산 - //
/*
2-3 트리에 데이터를 추가시에는 노드에 추가할 수 있을 때까지 데이터는 추가되고, 더 이상 저장할 장소가 없는 경우에는 노드를 분리하게 된다. 예시를 들어보자
30 60 20 순으로 데이터를 삽입할 것이다. 30으로 노드가 하나 생성한다. 이후 2-3 트리에는 하나의 노드에 2개의 데이터를 넣을 수 있으므로, 30 60 이 한 노드에 저장된다.
이후에 만약 20도 들어가게 되면, 저장할 장소가 더 이상 없으므로, 아예그냥 노드를 전체로 3개로 분리한다. 이때 중간값을 한 레벨 위로, 가장 작은 값을 왼쪽, 가장 큰 값을 오른쪽 노드로 만든다.


그럼 이제 경우에 따라서 '분리되는 과정' 을 자세히 보자.
1. 단말노드를 분리하는 경우
단말노드가 이미 2개의 데이터를 가지고 있는데, 새로운 데이터가 삽입되었을때의 경우이다.
만약 부모노드가 2-노드라면 그 3개로 쪼개질 노드 중에서, 중간값은 부모 노드로 올라가게 되고, 작은 값과 큰 값은 새로운 노드로 분리되게 된다.

만약 부모노드가 3-노드라면 2-노드와 동일시 하게 되지만, 부모 노드도 결과적으로 다시 분리되어야 한다. 이 분리는 비단말 노드를 분리하는 방법으로 이어진다.

2. 비단말 노드를 분리하는 경우
비단말 노드가 분리되야 하는 경우에는 중간값을 다시 부모 노드로 올려 보내고 작은 값과 큰값을 별개의 노드로 분리한다.
단 주의해야 할 것은 서브트리들도 둘로 분리 되게 해야 한다.

3.루트 노드를 분리하는 경우
이건 오히려 간단하다. 마찬가지로 middle을 위로 올리면 된다.
주의해야 할 점은 트리의 높이가 하나 상승하게 된다는 것이다. 그리고 그 middle이 전체 트리의 새로운 루트 노드가 되는 것이다.
*/



//2-3-4 트리
//하나의 노드가 4개의 자식까지 가질 수 있도록 2-3 트리를 확장한 것이다. 4개의 자식을 가질 수 있는 노드를 4-노드라고 부르며, 이 노드는 3개의 데이터를 가질수 있게 된다.
//각각 small, middle, large이라고 하자. 2-3트리와 매우 비슷하다. 단지 4-노드를 처리하는 부분만 추가하면 된다.


//2-3-4 트리에서 키를 삽입해야 할 단말노드가 2-노드 혹은 3-노드면 간단히 삽입하면 된다.
//문제는 삽입해야할 단말노드가 4-노드이면 후진 분할이 일어나게 된다. 따라서 2-3-4 노드에서는 이를 방지하고자 삽입노드를 찾는 순회 (루트에서 단말로 가는) 시에 4-노드를 만나면 미리 분할을 수행한다.
//즉 바로 노드에 데이터 3개인 것을 만나면 바로 분할하는 것이다. 이를 전진 분할이라고도 한다.


//이는 2-3 트리와 비교된다. 2-3트리는 삽입 또는 삭제를 위한 순회 (루트->단말) 와 분할과 합병의 영향으로 인한 순회(단말->루트)가 필요하다. 
//따라서 2-3 트리에 비하여 2-3-4의 장점은 루트에서 단말노드로 한번만 이동하면서 삽입이나 삭제가 가능하다는 것이다.

// 2-3-4 트리에서는 삽입을 위하여 루트에서 단말노드로 내려가는 동안 4-노드를 만나면 무조건 분할시킨다. 따라서 단말 노드에 도달하게 되면 단말노드의 부모노드는 4-노드가 아니라는 것이 보장된다.

