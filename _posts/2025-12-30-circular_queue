#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

//선형 큐는 지나가온 배열의 인덱스는 사용하지 못하며, 동시에 배열의 끝에 도달한다면, 요소를 추가하기 위해서는 모든 요소들을 왼쪽으로 옮겨야 하는데, 그 코드가 복잡하다는 단점이 있다.
//원형 큐는 이러한 단점을 보완하는 것으로, 배열의 끝인 MAX_QUEUE_SIZE -1 //대응 되는 인덱스가 먼저 증가(전위 연산자) 하고 나서, 요소를 대입한다 에 도달하면, 다음에 증가되는 값을 0이 되도록 하는 것이다.
//우선 원형큐는 선형 큐와 다르게 초기값을 0으로 둘다 설정한다. 나머지는 선형 큐와 비슷하다. 항상 front는 큐의 첫 번째 요소의 하나 앞을, rear은 마지막 요소를 가르킨다.
//front와 rear 모두 예를 들어 배열의 끝(MAX_QUEUE_SIZE -1) 이 5라고 치자. 그렇다면, 0 1 2 3 4 0 이런식으로 변화되어야 하므로, 나머지 연산 (% MAX_QUEUE_SIZE) 을 이용한다. 
//즉 front와 rear 을 (front(혹은 rear) +1) % MAX_QUEUE_SIZE 으로 둔다. //왜 front 와 rear을 + 1하고? => front는 항상 첫번째 요소의 앞을 가르키기에, 삭제하기 위해서는, rear은 새롭게 데이터를 추가하기 위해 빈 곳을 가르켜야 하므로.
//선형 큐와 원형 큐 모두 반드시, front나 rear이 먼저 증가 되고, 증가된 위치에 대하여 데이터를 다뤄야 한다. 삭제는 front, 대입은 rear과 관련있다.

//원형 큐에서 하나의 자리는 항상 비워놔야 한다. 그렇지 않으면 front와 rear이 같은 인덱스를 가르키 때, 이 상태가 포화상태인지, 빈 상태인지 분별이 안되기 때문이다.
//즉 여기서는 front 와 rear이 같으면 큐가 비워있는 상태로, front가 rear보다 하나 앞에 있으면 포화상태로 여긴다.


// ==========원형 큐 코드 시작 ======
#define MAX_QUEUE_SIZE 5
typedef int element;
typedef struct {
	element data[MAX_QUEUE_SIZE];
	int front, rear;
}QueueType;

void error(char* message) {
	fprintf(stderr, "%s\n", message);
	exit(1);
}

void init_queue(QueueType* q) {
	q->front = q->rear = 0; //초기 값을 0으로 설정.
}

int is_empty(QueueType* q) {
	return (q->front == q->rear); //같을 경우 공백상태 
}

int is_full(QueueType* q) {
	return ((q->rear + 1) % MAX_QUEUE_SIZE == q->front);  //front가 rear보다 하나 앞에 있다면 포화상태
}

void queue_print(QueueType* q) { //원형 큐 출력
	printf("QUEUE(front=%d rear%d) = ", q->front, q->rear);
	if (!is_empty(q)) {
		int i = q->front;
		do {
			i = (i + 1) % (MAX_QUEUE_SIZE);
			printf("%d | ", q->data[i]);
			if (i == q->rear)
				break;
		} while (i != q->front); 
	}
	printf("\n");
}

void enqueue(QueueType* q, element item) {
	if (is_full(q))
		error("큐가 포화상태입니다");
	q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;
	q->data[q->rear] = item;
}

element dequeue(QueueType* q) {
	if (is_empty(q))
		error("큐가 공백상태입니다");
	q->front = (q->front + 1) % MAX_QUEUE_SIZE;
	return q->data[q->front];
}

element peek(QueueType* q) {
	if (is_empty(q))
		error("큐가 공백상태입니다");
	return q->data[(q->front + 1) % MAX_QUEUE_SIZE]; //요소 값을 보기만 하는 거기에, front+1 시킨 인덱스를 반환하지, front 변화한것을 저장하지는 않는다.
}

//===========원형큐 코드 끝 =========

int main() {
	QueueType queue;
	int element;

	init_queue(&queue);
	printf("--데이터 추가 단계 --\n");
	while (!is_full(&queue)) {
		printf("정수를 입력하시오: ");
		scanf("%d", &element);
		enqueue(&queue, element);
		queue_print(&queue);
	}
	printf("큐는 포화상태입니다. \n\n");

	printf("--데이터 삭제 단계--\n");
	while (!is_empty(&queue)) {
		element = dequeue(&queue);
		printf("꺼내진 정수: %d \n", element);
		queue_print(&queue);
	}
	printf("큐는 공백상태입니다. \n");
	return 0;
}
