//Red-Black 트리
//이진 탐색 트리의 한종류이며 스스로 균형을 잡는 트리이다.
//마찬가지로 BST의 최악 (O(n))이라는 단점을 개선한 트리이다. 
//특징을 보자. 1) 모든 노드는 red혹은 black이며, 루트노드는 항상 black이다.

// nil 노드: 존재하지 않음을 의미하는 노드. 자식이 없을때, 자식을 nil노드라고 표기한다. 또한 값이 있는 노드와 동등하게 취급되며 RB트리에서는 단말노드가 즉 nil노드인 것이다.
// 2) 모든 nil 노드는 black이다. 또한 3) red의 자녀들은 항상 black이어야 한다. 즉 red가 연속적으로 존재할 수 없다.

// 4) 임의의 노드에서 자손 nil노드들까지 가는 경로들의 black 수는 같다. (자기 자신은 카운트에서 제외)
// 노드 x의 black height: 노드 x에서 임의의 자손 nil 노드까지 내려가는 경로에서의 black 수.
// 이러한 경로 black 성질을 만족하고 있고, 두 자녀가 같은 색을 가질 때, 부모와 두 자녀의 색을 바꿔줘도 이 성질은 여전히 만족한다.

//예를 들어보자.
/*
		     50(B,2)
	20(R,2)			  70(R,2)
10(B,1) 40(B,1)    60(B,1)   80(B,1)
		/					
	  30(R)

에서 

			 50(B,2)
	 20(B,1)		 70(R,2)
10(R,1)  40(R,1)    60(B,1)   80(B,1)
		/
	  30(R)    으로 만족하게 된다.  또한 20 10 40 에 대해서 색깔이 바뀌었지만 이들의 부모 50에 대해서는 black height가 바뀌지 않는다.
보시다 시피 바뀌어도 black height가 되기위한 임의의 노드에서 nil까지 가는데에 모든 경로에서의 black 수가 같다는 조건을 만족하게 된다.
((x,y) 에 있어서 x는 색깔을, y는 black height 를 의미 하였다) 
*/



//그럼 어떻게 균형을 잡는가?
//삽입/삭제시 보통 균형이 잃어지거니와, '노드가 red라면 자녀들은 black' 과 '임의의 노드에서 자손 nil노드들까지 가능 경로들의 black 수는 같다'가 위반되어지는데, 이를 해결하려 하면 된다.

//삽입 방식은 일반적인 BST와 동일하고, 삽입 후에 RB 트리 위반 여부를 확인한다. 그리고 삽입하는 노드는 항상 red여야 한다. (자손 nil노드까지 가는 black수 최대한 유지를 위하여)

//예를 들어보자. 처음 insert(50) 을 하였다. 그럼 한 노드가 생성되고 그에 딸린 두 nil노드는 black으로 고정한다.
//그러나 50은 현재 루트노드가 되므로 색깔을 black으로 바꿔준다. 

// 1) 삽입후에 루트노드가 red라면 black으로 바꿔준다.

//이제 insert(20) 과 insert(10)을 해보자. 이런 식으로 될것이다.
/*
		50(B)
	20(R)
10(R)
*/
//이렇게 되면 노드가 red라면 그 노드의 자식이 black이라는 조건을 어기게 된다.
//그럼 어떻게 해결해야 할까, BST의 특징(노드 기준 자식이 작으면 왼쪽 크면 오른쪽)과 RB의 조건을 모두 만족시키기 위해서는 이렇게 할 수 있다.
/*
		   20(B)
	10(R)			50(R)
*/

//즉 회전이다. 저 경우에는 20과 50의 색을 먼저 바꿔준 후 오른쪽으로 회전한 경우이다.

//LL 혹은 RR 처럼 구조가 되고 색깔 위반이 된 상황 & 부모의 형제가 black 이라면
//부모와 할아버지의 색을 바꾼후 할아버지 기준으로 오른쪽으로 회전한다. (모든 왼쪽, 오른쪽을 전체적으로 바꿔도 성립)


/*
다시 보자.

		    20(B)
	 10(R)			50(B) 
5(R)							//잘 보면 첫 예시 자체가 잘못되었다. 20노드 기준으로 nil까지의 black수가 경로에 따라 다르다. 하지만 편의상 설명을 위해 일단 생략.
의 경우라고 치자. 5의 노드는 10의 왼쪽 자녀다. 그리고 부모도 R이고, 20의 왼쪽 자녀이다. 즉 LL구조 이다. 
여기에서 부모의 형제관계인 50의 노드는 black이다. 이를 만족하므로 이렇게 될것이다.
20과 10의 색이 바뀌어 지고 20의 기준으로 오른쪽 회전.
		
	  10(B)			
5(R)		20(R)
				 50(B)

*/

/*
다음 경우이다. 마치 LR 과 같은 구조이다.

	  50(B)
20(R)
	  40(R)

AVL과 구조는 비슷하게 풀어내면 된다. L회전 이후 R회전이다.
차이점이라면 L회전 이후 40과 50의 색을 바꾼 것이 추가 된 것이다.


//삽입된 이후 LR 혹은 RL의 형태이며 색깔 위반이 된 상태 & 부모의 형제가 black이라면 한번 처음 L (R) 으로 회전 한 뒤 위의 RR (LL) 방식으로 해결
*/

/*
세번째 경우이다 봐보자. 
	  10(B)
5(R)		 50(R)
		 25(R)
역시나 규칙위반이고, 이번에는 RL 방식으로 해결하면 될거 같지만. 5라는 노드 (형제노드)도 R이 기에 옮길 수가 없다.

//그러기에, 이렇게 해야한다. 자녀의 색깔 5와 50이 같으므로 부모의 색깔과 바뀌어도 성질이 유지된다는 것을 이용하자.
//동시에 루트는 항상 Black이어야 하므로 RED으로 바꾼 10을 다시 Black으로 바꾼다.
	  10(B)
5(B)		 50(B)
		 25(R)
이러면 만족된다.

*/

//최종적으로 정리해보자.
//1. LL(RR)의 꼴이며 색깔 위반 & 삼촌의 색은 Black의 경우: 할아버지와 부모색 교체, R(L)회전
//2. RL(LR)의 꼴이며 색깔 위반 & 삼촌의 색은 Black의 경우: 먼저 R(L) 1회전,  이후 1번의 방식과 똑같이 처리.
//3. 삽입된 노드의 부모와 삼촌 모두 Red일 경우: 부모 & 삼촌 과 할아버지 끼리의 색 교체, 이후 할아버지에서 다시 확인 시작. (루트조건, 색깔 조건)
