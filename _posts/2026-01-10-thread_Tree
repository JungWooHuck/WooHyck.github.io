// 중위순회를 보면 단일 연결리스트와 비슷하게, root라는 포인터 변수를 통해서 모든 노드를 파악할 수 있지만, 단방향이다.
// 예컨대, 부모에서 자식 노드로 가는 것은 링크필드하면 된다. 그러나, 자식노드의 경우에는 어디로 가야하는지에 대한 정보가 아예 없다.
// 이를 해결하기 위하여, 그동안은 재귀 호출 혹은 스택을 이용하였지만, 이 또한, 노드의 수가 많아진다면 비효율적이 될수 있다는 단점이 존재한다.
// 그래서 다른 해결 방법으로 한 것이, NULL 링크를 활용하는 것이다.  NULL 링크에 중위 순회 시에 선행 노드인 중위선행자나 중위 순회시에 후속 노드인 중위 후속자를 저장시켜 놓은 트리가 스레드 이진 트리이다.
// 쉽게 말하면 왼쪽 스레드 → 중위 선행자 이고, 오른쪽 스레드 → 중위 후속자 이다.
// 그러나 만약 이런식으로 NULL링크에 스레드가 저장되면 링크에 자식을 가리키는 포인터가 저장되어 있는지 아니면 NULL이 저장되어야 하는 대신 스레드가 저장된 것인지 구별해주는 태그 필드가 따로 필요하다.

#include <stdio.h>
#define TRUE 1
#define FALSE 0

typedef struct TreeNode {
	int data;
	struct TreeNode* left, * right;
	int is_thread; //스레드 확인 변수, 맞을시 True
}TreeNode;

//		G
// C         F
//A   B    D   E

TreeNode n1 = { 'A', NULL, NULL,1}; //마지막 요소가 1은 중위 후속자를 가르키는 스레드가 있다는 뜻이다,
TreeNode n2 = { 'B', NULL, NULL,1};
TreeNode n3 = { 'C', &n1, &n2 ,0};
TreeNode n4 = { 'D', NULL, NULL,1};
TreeNode n5 = { 'E', NULL, NULL,0};
TreeNode n6 = { 'F', &n4, &n5 ,0};
TreeNode n7 = { 'G', &n3, &n6, 0};
TreeNode* exp = &n7;


TreeNode* find_successor(TreeNode* p) {
	//q는 p의 오른쪽 포인터
	TreeNode* q = p->right;
	//만약 오른쪽 포인터가 NULL이거나 스레드이면 오른쪽 포인터를 반환
	if (q == NULL || p->is_thread == TRUE)
		return q;

	//만약 오른쪽 자식이면 다시 가장 왼쪽 노드로 이동
	while (q->left != NULL) q = q->left; 
	return q;
}

void thread_inorder(TreeNode* t) {
	TreeNode* q;
	q = t;
	while (q->left) q = q->left; //가장 왼쪽 노드로 간다.
	do {
		printf("%c -> ", q->data);
		q = find_successor(q);
	} while (q);
}

int main() {
	n1.right = &n3;
	n2.right = &n7;
	n4.right = &n6;
	//스레드 설정
	
	thread_inorder(exp);
	printf("\n");
	return 0;
}

//코드를 읽어보자. 우선 위의 예시대로 중위 순회를 하였을때의 순서는 A C B G D F E 이렇게 된다. 이때 일반적인 이진트리 순회였다면, A에서 C로, B에서 G로, D에서 F로 즉 부모쪽으로 갈 방법이 없어서 재귀호출을 이용했었다.
//이 코드에서는 메인 함수를 보면 알자. 함수 안 변수 q =지만, 각각 NULL이 될 곳이었던 right 링크 필드에 스레드를 하였다. 이후  thread_inorder(exp) 를 하였다.
//여기서 이진스레드 중위순회에서 생각해야 하는 것는 대략 2가지이다. 
//1. 왼쪽, 루트, 오른쪽 순으로 순회하기에, 항상 왼쪽 자식 노드가 NULL이 될때까지 우선은 내려가야 한다.
//2. is_thread가 1이라면 중위 후속자를 가르키는 스레드임을,  0이라면 오른쪽 자식 노드이라고 구별해서 생각해야 한다.  

//그럼 이제 차근차근 보자. thread_inorder 에서  반복문을 통해 q = A가 먼저 된다. 그리고나서 find_successor(A) 를 호출한다.
//find_successor(A)를 보면, A->right 즉 main에 설정해 놓았던 C가 된다. 또한 is_thread == 1 이므로 그대로 스레드된 중위후속자 C를 반환한다.
//이후 출력되고 나서, find_successor(C)으로 간다. 함수 안에서 q = B가 된다. 이때, q가 NULL이 아닐 뿐더러, B는 스레드가 아니므로 if문은 넘어간다. 다음은 while문이다. 
// 이 while문이 있는 이유는 자식노드가 또 하나의 하위 트리구조에서의 루트역할을 한다면, 먼저 그 루트의 왼쪽 자식부터 순회해야 하기 때문이다. 하지만 아니므로 바로 B가 반환된다.
// 이후에 B는 G로 스레드를 , G는 q=F으로 되었다가 위에서 설명한 상황이 되었기에, while문에 걸려 D반환, D는 스레드로 F반환, F는 자식노드로 E, 이후에는 E의 right는  NULL이 되므로 NULL을 반환하고, inorder의 do-while문도 종료된다.
