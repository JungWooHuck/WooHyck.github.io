//기수 정렬
//기수정렬은 레코드를 '비교하지 않는' 정렬 방법이다.
//그렇기에 그동안 정렬에 있어서의 시간 복잡도 O(nlog n) 이라는 이론적인 하한선을 깰 수 있는 유일한 기법이다. 기수 정렬의 시간 복잡도는 O(kn)이다. (이때 k는 자릿 수 이다)

//자 일단 보자. 기수는 숫자의 자리수이다. 기수정렬의 단점이자 제한은 이것이다.
//항상 정렬하고자 하는 요소들이 같은 자릿수의 수여야 하거나, 모두 같은 글자 수의 문자열 이어야 한다.
//이를 가정으로 하고 (7,4,2,1,3,0) 이러한 배열이 있다고 하자. 이는 기수 정렬을 이용할 수 있다.
//십진수에서는 각 자리수가 0에서 9까지의 값만 가지는 것을 생각하여,  0~9 을 담는 10개의 버킷을 만들어서 입력 데이터를 각 자리수의 값에 따라 상자에 넣는다. 각 왼쪽상자부터 순차적으로 버킷 안에 들어있는 숫자를 순차적으로 읽는다.
//그러면 정렬된 숫자를 얻을 수 있다. 이때 기억하자. 버킷에 넣고 빼고를 동작했을뿐 절대로 비교연산을 하지 않았다.
//만약 여러 자릿수일때는 우선 가장 낮은 자리수로 정렬한 다음 차츰 높은 자리수로 정렬해야 한다.

//이제 구현단계로 보자. 각각의 버킷에서 먼저들어간 숫자는 먼저 나와야 한다. 예를 들어보자. (26,35,28) 이 있다. 먼저 제일 낮은 자리수에 맞춰서 정렬하자. (35, 26, 28) 이 된다. 이후에 자릿수를 높이고 정렬을 해보자.
// 3이라는 버킷에는 그냥 35가 들어간다. 2라는 버킷을 보자. 26 28 이 순서대로 들어간다. 즉 정렬이 제대로 되려면 먼저들어간 26이 먼저 나와야 한다.
// 따라서 각각의 버킷은 큐로 구현 되어야 한다.
// 또한 만약 문자를 표현하고자 한다면 알파벳 문자에 대해서는 26개의 버킷이 필요하는 등, 버킷의 개수는 키의 표현 방법과 관계가 밀접하다.


#include <stdio.h>
#include <stdlib.h>

#define MAX_QUEUE_SIZE 100
typedef int element;

typedef struct {
	element data[MAX_QUEUE_SIZE];
	int front, rear;
}QueueType;

void error(char* message) {
	fprintf(stderr, "%s\n", message);
	exit(1);
}

void init_queue(QueueType* q) {
	q->front = q->rear = 0;
}

int is_empty(QueueType* q) {
	return (q->front == q->rear);
}

int is_full(QueueType* q) {
	return ((q->rear + 1) % MAX_QUEUE_SIZE == q->front);
}

void enqueue(QueueType* q, element item) {
	if (is_full(q))
		error("큐가 포화 상태입니다");
	q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;
	q->data[q->rear] = item;
}

element dequeue(QueueType* q) {
	if (is_empty(q))
		error("큐가 공백상태입니다");
	q->front = (q->front + 1) % MAX_QUEUE_SIZE;
	return q->data[q->front];
}

#define BUCKETS 10
#define DIGITS 2
void radix_sort(int list[], int n) {
	int i, b, d, factor = 1;
	QueueType queues[BUCKETS]; //구조체 배열로, 버켓 생성

	for (b = 0; b < BUCKETS; b++)
		init_queue(&queues[b]); //큐들을 모두 초기화

	for (d = 0; d < DIGITS; d++) {
		for (i = 0; i < n; i++) //데이터들을 자리수에 따라 큐에 삽입, n은 데이터의 요소수.
			enqueue(&queues[(list[i] / factor) % 10], list[i]);  //잘 보자. 처음에는 %10으로만 나뉘어 제일 낮은 자릿수인 일의 자릿수에 맞춰서 삽입되어 진다. 계산된 일의자리수에 맞춰서 버킷(큐)에 들어간다.
		//이때 인덱스 값은 중요하지 않다. 오로지 인덱스에 대응되는 요소 값만을 볼 뿐이다.

		for (b = i = 0; b < BUCKETS; b++) //버킷에서 꺼내어 list로 합친다
			while (!is_empty(&queues[b]))
				list[i++] = dequeue(&queues[b]);
		factor *= 10;  //그 다음 자리수로 간다.
	}
}

#define SIZE 10

int main() {
	int list[SIZE];
	srand(time(NULL));
	for (int i = 0; i < SIZE; i++)
		list[i] = rand() % 100; //...? 이러면 한자리수도 나오게 될 수 있어서,,위험하지 않나?
	//답: 걱정말자. 한자리수를 여기에서는 04 으로 생각한다. 즉 0번 버킷으로 가게 되는 것이다.
	radix_sort(list, SIZE);
	for (int i = 0; i < SIZE; i++)
		printf("%d ", list[i]);
	printf("\n");
	return 0;
}
