//머쉰 스케줄링
//어떤 공장에 동일한 기계가 m개 있고, 처리해야 하는 작업들이 n개 있으며 각 작업들은 제각각 해결하는데에 시간이 다르다. 여기서 m개의 기계를 모두 활용하여 최소한의 시간으로 n개의 작업을 끝내는 것을 머쉰 스케줄링이라 한다.
//이러한 해를 찾는데에 한 가지 방법이 있다. LPT 이다.
//간단하게, 최소히프를 이용하여,제일 시간이 많이 걸릴 n의 작업을 우선 기계에 배치 한 후, 순차적으로 가장 먼저 사용가능하게 되는 기계에 일을 할당시킨다.

#include <stdio.h>
#define MAX_ELEMENT 200

//이때 중요한 정보가 있는데, 기계의 종료시간이 중요하다. 기계의 종료시간이 최소인 기계가 항상 선택되어야 하기 때문이다.
typedef struct {
	int id;
	int avail;
}element;

typedef struct {
	element heap[MAX_ELEMENT];
	int heap_size;
}HeapType;


HeapType* create() {
	return (HeapType*)malloc(sizeof(HeapType));
}

void init(HeapType* h) {
	h->heap_size = 0;
}

// 현재 요소의 개수가 heap_size인 히프 h에  item을 삽입한다.

void insert_min_heap(HeapType* h, element item) {
	int i;
	i = ++(h->heap_size); //i에다가 heap_size+1 즉 배열의 마지막요소의 다음요소 인덱스 저장. 동시에 heap_size 증가.

	while ((i != 1) && (item.avail < h->heap[i / 2].avail)) { //..? item의 avail보다 부모의 avail이 더 크면 최소히프는 가장 작은 값일 수록 루트에 가깝기 배치되어야 하므로.
		h->heap[i] = h->heap[i / 2]; //그 자식 노드에 부모노드의 값을 덮어 대입한뒤.
		i /= 2; //i는 부모노드의 인덱스로 이동.
	}
	h->heap[i] = item;
}

element delete_min_heap(HeapType* h) {
	int parent, child;
	element item, temp;

	item = h->heap[1]; //루트 값
	temp = h->heap[(h->heap_size)--]; //히프의 마지막 값의 요소
	parent = 1;
	child = 2;
	while (child <= h->heap_size) {
		if ((child < h->heap_size) && (h->heap[child].avail) > h->heap[child + 1].avail) //child 가 히프사이즈보다 작고, 동시에, 두개의 자식 노드중 만약에, 더 작은 값이 child+1 인덱스 노드라면
			child++; //+1 하여 그 노드로 교체
		if (temp.avail < h->heap[child].avail) break; //만약 부모로 지정된 노드와 그의 자식노드 중, 자식노드가 더 크다면, 그 부모자리가 맞는것으로 반복을 멈춘다

		h->heap[parent] = h->heap[child]; //위의 조건문에 걸리지 않았다면, 부모노드의 자식노드를 교체 시키게 한뒤,
		parent = child; //부모노드의 인덱스는 그 자식노드의 인덱스로 되고
		child *= 2; //자식노드는 *2으로 하여 새로 바뀐 부모노드에 맞게 인덱스가 조정된다.
	}
	h->heap[parent] = temp; //반복이 멈추면 최종적으로 그 인덱스에 대입시킨다.
	return item;
}

#define JOBS 7
#define MACHINES 3

int main() {
	int jobs[JOBS] = { 8,7,6,5,3,2,1 }; //작업은 정렬되어 있다고 가정
	element m = { 0,0 };
	HeapType* h;
	h = create();
	init(h);


	for (int i = 0; i < MACHINES; i++) {
		m.id = i + 1; //식별을 편히 하기 위하여 0은 사용하지 않는다.
		m.avail = 0;
		insert_min_heap(h, m); //빈 히프에 이제 각 {id, avail} 의 쌍 element 자료형을 최소 히프의 규칙으로 삽입시킨다. 
	}

	//최소 히프에서 기계를 꺼내서 작업을 할당하고 사용가능 시간을 증가 시킨후에 다시 최소 히프에 추가한다.
	for (int i = 0; i < JOBS; i++) {
		m = delete_min_heap(h);//heap에 들어가는 것은 작업이 아니라 결국에는 '기계들' 이다
		printf("JOB %d을 시간=%d부터 시간=%d까지 기계 %d번에 할당한다. \n", i, m.avail, m.avail + jobs[i] - 1, m.id);
		m.avail += jobs[i]; //avail은 기계의 종료시간으로 즉, 작업의 시간만큼 증가시킨뒤, 다시 히프에다가 넣는다.
		insert_min_heap(h, m);
	}
	return 0;
	
}
