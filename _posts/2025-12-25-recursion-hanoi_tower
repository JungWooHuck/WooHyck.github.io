#include <stdio.h>
void hanoi_tower(int n, char from, char tmp, char to) {
	if (n == 1)printf("원판 1을 %c에서 %c로 옮긴다. \n", from, to);
	else {
		hanoi_tower(n - 1, from, to, tmp);
		printf("원판 %d 를 %c에서 %c으로 옮긴다.\n", n, from, to);
		hanoi_tower(n - 1, tmp, from, to);

	}
}
int main() {
	hanoi_tower(3, 'A', 'B', 'C');
	return 0;
}

------------------------------------------------------------------------------------------------------------

순환 구조를 가장 효과적으로 사용할 수 있는 알고리즘 중 하나가 하노이의 탑이다.
코드의 이해를 위하여 n =3으로, n은 원판 수, from은 시작, tmp는 보조, to는 목표 막대로 가정한다.
hanoi_tower(n - 1, from, to, tmp); 의 재귀 호출은 '맨 아랫 탑 제외 모두 보조막대로 이동한다' 라는 뜻이다.
hanoi_tower(n - 1, tmp, from, to); 의 재귀 호출은 'tmp를 시작으로, from을 보조 막대로 바꾸어 생각한다'는 뜻이다.
"-"의 개수는 함수의 진행에 있어서, 함수 호출의 깊이 혹은 재귀호출로서의 깊이를 뜻한다.

-------------------------------------------------------------------------------------------------------------
해석:
hanoi(3,A,B,C)
 -hanoi(2,A,C,B) //if 조건문에 안걸림, else문으로 가서 또 두개의 재귀호출을 하게 한다.
 --hanoi(1,A,B,C)
 --조건문 n==1걸림
 -- "원판 1을 A에서 C로 옮긴다." (printf문)
 -"원판 2를 A에서 B로 옮긴다."(printf문) //우선 재귀호출 hanoi(1,A,B,C)은 끝낫으니, -hanoi(2,A,C,B) 의 범위로 돌아와서 다음 코드인 printf 문 실행이다.
 --hanoi(1,C,A,B) //이후 그 아래 재귀호출.
 --n==1걸림
 --"원판 1을 C에서 B로 옮긴다." (printf문)
hanoi(3,A,B,C) //여기서 많이 햇갈릴 수 있다. 하지만 기억하자, 재귀 호출은 다른 함수로 점프하는 것이 아닌, "여기서 잠깐 멈춘다. 이후 저 함수가 끝날 때 까지 기다린다" 로 보자.
//그럼 처음부터 봐보자. hanoi(3,A,B,C) 를 이미 한 상황에서 일단은 -hanoi(2,A,C,B) 호출했다. 그리고 저 재귀함수는 다른 2개의 재귀호출을 하도록 이끌고 나서 끝났다. 따라서 그 다음 else문의 printf은 hanoi(3,A,B,C)의 것이다.

"원판 3을 A에서 C로 옮긴다" (printf문)
-hanoi(2,B,A,C);
--hanoi(1,B,C,A);
--"원판 1을 B에서 A로 옮긴다." (printf문)
-"원판 2를 B에서 C로 옮긴다." (printf문)
--hanoi(1,A,B,C)
-"원판 1을 A에서 C로 옮긴다." (printf문)
끝.
결론:  
1. 원판 1을 A에서 C로 옮긴다
2. 원판 2를 A에서 B로 옮긴다
3. 원판 1을 C에서 B로 옮긴다
4. 원판 3을 A에서 C로 옮긴다
5. 원판 1을 B에서 A로 옮긴다
6. 원판 2를 B에서 C로 옮긴다
7. 원판 1을 A에서 C로 옮긴다     // 이런 순서로 출력된다.
