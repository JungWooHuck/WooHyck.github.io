빅오 표기법 및 시간 복잡도.

우선 n이 무엇인지 코드 내에서 잡는 것이 1순위.
이후

1) 반복문 횟수. 총 몇번 도는가?
- 단일 반복문 -
for (int i = 0; i<n; i++);

while(n>0){
  n--;
}
두 경우다 n번 실행되므로 O(n)

- 중첩 반복문-
각 반복문에 있어서, 반복 횟수만큼 서로 곱한다.
for (int i = 0; i<n; i++){
  for (int j = 0; i<n; j++){
    printf("%d", i);
  }

n*n = O(n^2)

for (int i = 0; i<n; i++){
  for(int j = 0; j<m; j++){
    ...
  }
}
n*m = O(nm)

2) 반복횟수가 마치 절반 씩 계속 줄어든다면, log n 꼴이다.
while(n>1){
  n = n/2;
}
이 경우에 n은 n/2, n/4, n/8 이런식으로 되기에,
시간복잡도는 O(log n) 이다.

3) if 문은 상수 시간복잡도. 한번만 확인하므로 O(1) 이다.
4) 코드가 여러개가 있을떄, 구한후 이내 복잡도 끼리 더한다. 그리고 다시 빅오 표기법으로 정리한다.
예를 들어 어느 코드에 이중반복문과 단일 반복문 코드가 연달아 나온다고 하면 O(n^2), O(n) = O(n^2 + n) = O(n^2) 이런식으로다.
  
