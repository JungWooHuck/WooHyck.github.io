//최소비용 신장 트리
//신장트리: 원래 그래프에서 일부 간선만을 골라서, 모든 정점을 무조건 다 포함해야 하는 동시에 사이클이 없는 트리 형태가 되어야 하는 되는 것이다.
//이에 기반하여 잘 생각하자. 정점에 있어서 정점 수가 n개 라면 정점을 모두 포함하면서 사이클이 안되려면 간선 수는 반드시 n-1 개이어야 한다.

//이를 DFS와 BFS에 연결해보자. 둘의 탐색의 경우 그동안 인지하지 못할 수 있으나, 탐색할때 이미 방문한 정점에 대해서의 간선은 절대로 사용하지 않았다.
//오로지 방문한 적이 없는 정점에 대해서만 그 경로의 간선만을 이용했다. 즉, 신장트리는 이 탐색에 있어서 사용한 간선들만을 표시하면 된다는 것이다.

//따라서 신장트리는 그래프의 최소 연결 부분 그래프로. ...쉽게 보면 이렇게 보면 된다. 간선의 개수가 최소인 트리이다.
//그러나 잘 생각해보자. 이는 각 링크의 구축 비용이 같지 않다는 것이다.  각 간선에 있어서의 가중치는 대부분 다르기 나름이다.
//예를 들어보자. 도로를 모두 연결해야 하는데, 아무리 적은 간선이라 할지라도, 그 간선(도로)들의 길이가 다른 도로보다 더욱 더 길다고 생각해보자. 
//그럼 오히려 다른 방법으로 도로를 연결하는 것보다 비효율적이 될 것이며 시간이 더 걸릴 것이다.

//이를 해결하기 위해서, 최소비용신장 트리(MST)가 나온 것이다. 모든 정점을 연결하면서 간선수는 n-1개이고 총 가중치 합이 최소인 신장트리이다.

//최소비용신장 트리를 구하는 대표적인 방법은 KrusKal과 Prim이 각각 제안한 두가지의 알고리즘이 있다.
//일단 우선 Kruskal의 MST 알고리즘 봐보자.
//명심하자 무조건 지켜야할 전제는 이것이다. 간선의 가중치의 합이 최소, n-1개의 간선만을 사용, 모든 정점 포함, 사이클 포함 X

//Kruskal의 알고리즘은 탐욕적 방법(greedy method) 를 이용한다. 매 순간의 선택에 있어서 그 당시 가장 최적이라고 생각한 해답들을 모아서 최종적인 해답을 만드는 것이다.
//예컨대, 이런식으로 한다 먼저 그래프의 간선들을 가중치의 오름차순으로 정렬한다. 그러면 정렬된 간선들의 리스트에서 순차적으로 보면서 '사이클을 형성하지 않는' 간선을 찾아서 현재의 최소 비용 신장 트리의 집합에 추가한다.
// 즉 제일 중요한 것은 어떤 간선을 신장 트리의 집합에 추가할때 사이클이 되느냐의 유무인 것이다. 
//이는 이런식으로 생각하면 된다. "간선의 양끝 정점이 같은 집합에 속하면 사이클이 형성된다. 다른 집합에 속할 경우에는 추가 하여도 된다. 이 검사의 알고리즘을 union-find 알고리즘이라 한다."

//undion-find 연산도 봐보자. union(x,y) 는 원소 x와 y가 속해있는 집합을 입력으로 받아서 2개의 집합의 합집합을 만든다.
//find(x) 는 원소 x가 속해있는 집합을 반환한다.
//예를 들어 S={1,2,3,4,5,6} 의 집합을 가정하자. 처음에는 집합의 원소를 하나씩 분리하여 독자적인 집합으로 만든다. 이렇게 말이다. {1}, {2}, {3}, {4}, {5}, {6}
//여기서 union(1,4) 와 union(5,2)를 했다고 치자. 그럼 {1,4}, {5,2}, {3}, {6} 이 될거다. 또 여기에서 union(4,5) 와 union(3,6)을 하면 {1,4,5,2}, {3,6} 이렇게 되는 것이다.

//그럼 union은 어떻게 구현하는가. "부모 포인터 표현"으로 구현할 것이다. 부모 포인터 표현이란, 각 원소가 자신의 부모 원소를 가리키도록 하여 트리 구조로 집합을 표현하는 방식으로, 루트 노드가 해당 집합의 대표 원소가 된다.
//잘 생각해보자 union-find에서 생각해야 하 것은 이것이다. "두 원소가 같은 집합인가, 두 집합을 합칠 수 있는가" 이것이다.
//또한 자식관계나 형제등의 정보도 필요 없다. 그냥 어느 집합에 속해있는다만 중요하기에, 부모 노드만 알면 된다. 즉 자식정보가 아예 없는 방식이기에 다른 일반적인 상황에선 못쓰긴 한다.
//각 노드에 대해 그 노드의 부모에 대한 포인터만 저장하지만, 실제로 포인터 변수를 활용하는 것이 아닌 1차원 배열로 표현할 것이다.
//초기값은 -1으로 부모노드가 없는 단일 집합일때를 의미한다고 치자. 예를 들어보자
// A B C D E 모두 -1로 저장되어있다. 이 상태에서 union(C,E) 가 실행된다면 E의 인덱스의 값 -1을 C의 인덱스 2으로 바꾸는 것이다.

//이렇게 생각하자. 같은 집합인가? == 같은 루트 노드인가? 와 같은 뜻이다.

#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

#define MAX_VERTICES 100 //최대 정점 수
#define INF 1000 //무한대 값 (간선의 가중치 초기화 시 사용)

int parent[MAX_VERTICES]; //부모 노드를 저장하는 배열

void set_init(int n) {
	for (int i = 0; i < n; i++)
		parent[i] = -1; //모든 노드를 독립 단일 집합으로 초기화 한뒤, 모든 노드는 속한 집합이 없으므로 (여기서는 부모 루트가 없다는 뜻으로) -1으로 저장.
}

int set_find(int curr) {
	if (parent[curr] == -1)
		return curr;  //단일독립 집합. ..혹은 자신이 루트노드라면 스스로를 반환한다.
	while (parent[curr] != -1)
		curr = parent[curr]; //부모를 계속 따라가서 루트 노드까지 탐색
	return curr;
}

void set_union(int a, int b) { //집합 병합
	int root1 = set_find(a);
	int root2 = set_find(b); //두 노드의 집합의 루트 
	if (root1 != root2) //두 노드가 속한 집합이 서로 다를 경우에만 병합한다. 이때 병합은 간단히 root2 의 인덱스의 값을 root1로 즉 roo2의 부모를 root1으로 설정한다.
		parent[root2] = root1;
}

struct Edge {
	//간선을 나타내는 구조체
	int start; //시작 정점
	int end; //도착 정점
	int weight; //간선의 가중치
};

typedef struct GraphType {
	//그래프를 나타내는 구조체
	int no_v; //그래프의 정점 수
	int no_e; //그래프의 간선 수
	struct Edge edges[2 * MAX_VERTICES]; //간선 리스트, 신장트리의 규칙과 별개로, 최대로 나타날수 있는 간선의 수는 2*를 한 수 이기에. 
}GraphType;

void graph_init(GraphType* g, int v) {
	g->no_v = v;
	g->no_e = 0;
}

void insert_edge(GraphType* g, int start, int end, int w) { //간선 삽입 함수
	if (g->no_e >= 2 * MAX_VERTICES) {
		fprintf(stderr, "간선의 수가 최대값을 초과했습니다.\n");
		return;
	}
	g->edges[g->no_e].start = start; //시작 정점 설정
	g->edges[g->no_e].end = end; //끝 정점 설정
	g->edges[g->no_e].weight = w; //가중치 설정
	g->no_e++; //간선 수 증가
}

int compare(const void* a, const void* b) { //추측점: 간선들 끼리의 가중치 비교 함수.
	struct Edge* x = (struct Edge*)a;
	struct Edge* y = (struct Edge*)b;
	if (x->weight == y->weight)
		return x->start - y->start; //가중치가 같다면 오른차순으로 정렬한다.
	return x->weight - y->weight;  
}

void kruskal(GraphType* g) {
	int edge_accepted = 0;  //현재까지 선택된 간선의 수
	int uset, vset;  //두 정점이 속한 집합 번호
	struct Edge e;

	set_init(g->no_v); //우선 모든 정점을 독립 단일 집합으로 설정한다.
	qsort(g->edges, g->no_e, sizeof(struct Edge), compare);  //간선을 가중치에 맞춰서 오름차순으로 정렬한다. (정렬 규칙이 compare으로 되는 것이다.) qsort는 반환값의 부호만 체크하며, 이를 토대로 정렬한다.
	//예컨대 어느 함수의 규칙을 따라서 그 규칙에 있어서 compare(a,b) 에서 가중치를 이용하여 임의로 비교하였을때 음수의 반환값이 나오면 a가 b보다 앞에, 양수의 값이 나오면 b를 a보다 앞에 두는 것이다. 이런식으로 전체 배열을 정렬한다.

	printf("크루스칼 최소 신장 트리 알고리즘\n");
	int i = 0;
	while (edge_accepted < (g->no_v - 1) && i < g->no_e) { // 앞 조건은 모든 간선의 수는 정점수의 -1만큼 무조건 있어야 하고, i는 단순히 정렬될 배열 간선을 인덱스를 순회할 숫자이다.
		e = g->edges[i]; //이미 오름차순으로 정렬되었기에 이 간선 선택은 탐욕적 방법에 맞게, 가중치가 가장 낮은 간선인 것이다.
		uset = set_find(e.start); 
		vset = set_find(e.end); //면밀하게 봐야할 것은 이거다. 그 선택한 간선의 양끝 정점이 같은 집합에 있는가 없는가. 있다면 간선을 연결한 순간 사이클이 만들어 지기에 넘어가고, 없다면 그대로 채택
		if (uset != vset) {
			printf("간선 %d: (%d -> %d) (비용: %d) 선택\n", edge_accepted + 1, e.start, e.end, e.weight);
			edge_accepted++; //채택하였으므로 증가.
			set_union(uset, vset); //이후 두 집합을 병합시킨다.
		}
		i++;
		

	}
	if (edge_accepted < g->no_v - 1) {
		printf("오류: 그래프가 연결되어 있지 않아 최소 신장 트리를 생성할 수 없습니다. \n");
	}
}


int main() {
	GraphType* g = (GraphType*)malloc(sizeof(GraphType));
	graph_init(g, 7);  //그래프 초기화: 정점을 7개로 설정

	insert_edge(g, 0, 1, 29);
	insert_edge(g, 1, 2, 16);
	insert_edge(g, 2, 3, 12);
	insert_edge(g, 3, 4, 22);
	insert_edge(g, 4, 5, 27);
	insert_edge(g, 5, 0, 10);
	insert_edge(g, 6, 1, 15);
	insert_edge(g, 6, 3, 18);
	insert_edge(g, 6, 4, 25);

	kruskal(g);
	free(g);
	return 0;
}
