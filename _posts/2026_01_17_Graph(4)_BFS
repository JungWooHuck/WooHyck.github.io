//너비 우선 탐색: BFS는 시작 정점으로 부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회방법이다. DFS랑 비교해보자. DFS는 그대로 계속 한 정점에서 이동하면 또 그 정점에서 계속 먼저 깊게 내려가는 탐색 방식이다.
//어느 한정점 기준 자식 노드(주변 노드) 즉 제일 가까운 노드들을 먼저 탐색하는 것이기에, 선입선출의 방식인 큐를 이용하여 구현한다. 자 전의 BFS의 사진 기준으로 다시 설명하자.
//빈 큐 []가 있고 시작정점은 0이라고 치자. 우선 0이 들어오자마자 이후에 반환되고 출력된 다음, 0의 주변 노드들에 따라서 큐에 [1,2,4] 가 들어온다. 
//이후에 선입선출로 보자. 우선 1이 나오고 출력된다. 이후 1의 주변 노드를 보자. 다 방문하였으므로 멈춘다 [2,4]
//이번엔 2가 나온다. 2의 주변노드는 3이 있으므로 큐에 3이 들어간다. [4,3]
//여기에서 DFS와의 차이가 더 잘 드러난다. 만약 깊이우선이였다면 3기준으로 하여 주변 노드를 찾을 것이다. 하지만, 너비우선의 경우. 선입선출의 큐의 특성과 더불어, 4를 먼저 빼놓고 출력된다.
//이후 큐에 남은 것은 [3] 으로 3이 출력된다. 그럼 순서는 0,1,2,4,3 으로 된다. 이제 코드로 구현해보자.

#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
#define MAX_QUEUE_SIZE 10

typedef int element;

typedef struct {
	element queue[MAX_QUEUE_SIZE];
	int front, rear;
}QueueType;

//큐를 간단하게 복습하자. FIFO 선입 선출의 방식으로 핵심적으로 있는 변수는 front, rear이 있었고 연산에는 enqueue, dequeue, peek 가 있었다.
//큐는 선형큐와 원형큐 이렇게 있으며, 원형큐의 기준으로 보면, front,rear의 초기값은 0으로 설정된다.
//이후 공백과 포와의 구분을 위하여 한칸을 희생하여 front == rear의 경우를 공백으로 본다. 
//데이터가 삭제될때는 front를, 데이터가 증가할때는 rear을 주로 이용하며, 마지막 인덱스 이후 다시 처음 인덱스로 돌아오는 원형큐의 성질에 맞춰서
//(front(혹은 rear) +1) % MAX_QUEUE_SIZE 으로 dequeue() (혹은 enqueue())을 처리 한다. 

void error(char* message) {
	fprintf(stderr, "%s\n", message);
	exit(1);
}

void queue_init(QueueType* q) {
	q->front = q->rear = 0; //초기값 설정
}

int is_full(QueueType* q) {
	return ((q->rear + 1) % MAX_QUEUE_SIZE == q->front); //rear이 front의 한칸 뒤에 있다면 포화상태
}

int is_empty(QueueType* q) {
	return (q->front == q->rear); //공백상태
}
void enqueue(QueueType* q, element item) {
	if (is_full(q))
		error("큐가 포화상태입니다");
	q->rear = (q->rear + 1) % MAX_QUEUE_SIZE;
	q->queue[q->rear] = item;
} // 빈 큐에 처음으로 삽입할경우에는 인덱스 0이 아닌 1부터 시작하게 된다. 그렇게 하여 rear은 마지막 요소를, front는 첫 요소의 앞을 가르키게 하게끔한다.

element dequeue(QueueType* q) {
	if (is_empty(q))
		error("큐가 공백상태입니다.");
	q->front = (q->front + 1) % MAX_QUEUE_SIZE;
	return q->queue[q->front]; //삭제시에 따로 그 인덱스 값을 없애는 것이 아니라, 그저 front범위를 조절하는 것이다. 명심하자. 큐에서의 유효한 데이터는  front기준 뒤 노드부터, rear기준 노드까지 이다.
}

#define MAX_VERTICES 50
typedef struct GraphType {
	int n;
	int adj_mat[MAX_VERTICES][MAX_VERTICES];
}GraphType;
int visited[MAX_VERTICES];

void graph_init(GraphType* g) {
	int r, c;
	g->n = 0;
	for (r = 0; r < MAX_VERTICES; r++)
		for (c = 0; c < MAX_VERTICES; c++)
			g->adj_mat[r][c] = 0;
}

void insert_vertex(GraphType* g, int v) {
	if (((g->n) + 1) > MAX_VERTICES) {
		fprintf(stderr, "그래프: 정점의 개수 초과");
		return;
	}
	g->n++;
}

void insert_edge(GraphType* g, int start, int end) {
	if (start >= g->n || end >= g->n) {
		fprintf(stderr, "그래프: 정점 번호 오류");
		return;
	}
	g->adj_mat[start][end] = 1;
	g->adj_mat[end][start] = 1;
}

void bfs_mat(GraphType* g, int v) {
	int w;
	QueueType q;

	queue_init(&q);
	visited[v] = TRUE;
	printf("%d 방문 -> ", v); 
	enqueue(&q, v); //시작 정점을 큐에 저장한다.
	while (!is_empty(&q)) {
		v = dequeue(&q); //먼저 큐에서 정점을 반환시키고 빼낸다. 이후에 이 코드에 인하여 다음으로 시작될 정점이 계속 해서 바뀐다.
		for (w=0; w<g->n; w++) //이후 인접 정점을 탐색한다.
			if (g->adj_mat[v][w] && !visited[w]) {
				visited[w] = TRUE;
				printf("%d 방문 -> ", w); 
				enqueue(&q, w); //방문한 정점을 이후 큐에 저장한다.
			}
	}
	
}

int main() {
	GraphType* g;
	g = (GraphType*)malloc(sizeof(GraphType));
	graph_init(g);
	for (int i = 0; i < 6; i++)
		insert_vertex(g, i);
	insert_edge(g, 0, 2);
	insert_edge(g, 2, 1);
	insert_edge(g, 2, 3);
	insert_edge(g, 0, 4);
	insert_edge(g, 4, 5);
	insert_edge(g, 1, 5);


	printf("너비우선탐색\n");
	bfs_mat(g, 0);
	printf("\n");
	free(g);
	return 0;
}
//기억하자 BFS는 시작 정점으로 부터 거리가 가까운거부터 먼순으로 항상 탐색한다.
