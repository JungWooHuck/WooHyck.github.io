// (행,렬) 을 위치 기준으로 하며, 우선 미로에 있어서 우선 길을 간후, 길에 막히면, 다른 경로로 가되, 가장 가까운, 최근에 저장한 경로로 가야한다.
//그렇기에 최근 가장 가까운 (갈림길의) 경로로 가기 위해서 스택을 이용한다. 
//현재 위치 기준 위,아래,왼쪽,오른쪽 순서대로 보거니와, 이동이 가능한 칸의 경우에는 스택에 순서대로 저장한다. 이후 스택에서 맨 위에 있는 요소를 꺼내어 현재 위치로 지정한뒤, 이것을 반복한다.
//단, 한 번 거쳐간 위치를 다시 검사하지 않도록 표시를 해야한다. 무한루프에 걸릴 수 있으므로.
//미로는 이차원 문자배열을 이용할 것이다. 배열의 값이 0이면 갈 수 있는 길, 1이면 갈 수 없는 벽, 출구는 x로 표기한다. 방문을 이미 한 곳은 '.' 으로 저장한다.


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAZE_SIZE 6
#define MAX_STACK_SIZE 100


typedef struct {
	short r;
	short c;
}element; // (행,열) 을 저장하기 위해, 구조체를 구현하여 스택에 쌓도록 하는 것이다.
	

typedef struct {
	element data[MAX_STACK_SIZE];
	int top;
}StackType;

void init_stack(StackType* s) {
	return (s->top = -1);
}

int is_empty(StackType* s) {
	return (s->top == -1);
}

int is_full(StackType* s) {
	return (s->top == (MAX_STACK_SIZE - 1));
}


void push(StackType* s, element item) {
	if (is_full(s)) {
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else s->data[++(s->top)] = item;
}

element pop(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];
}

element peek(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[s->top];
}

element here = { 1,0 }, entry = { 1,0 };

char maze[MAZE_SIZE][MAZE_SIZE] = {  //이차원 배열로 미로 표현.
	{'1', '1', '1', '1', '1', '1'},
	{'e', '0', '1', '0', '0', '1'},
	{'1', '0', '0', '0', '1', '1'},
	{'1', '0', '1', '0', '1', '1'},
	{'1', '0', '1', '0', '0', 'x'},
	{'1', '1', '1', '1', '1', '1'},
};

void  push_loc(StackType* s, int r, int c) {
	if (r < 0 || c < 0) return; //경계 처리 및 에러.
	if (maze[r][c] != '1' && maze[r][c] != '.') {
		//벽이 아니고, 이미 왔던 곳이 아니라면
		element tmp;
		tmp.r = r;
		tmp.c = c;
		push(s, tmp); //스택에다가 구조체, 마치 (행,열) 의 쌍으로 저장한다.
	}
}

void maze_print(char maze[MAZE_SIZE][MAZE_SIZE]) {
	printf("\n");
	for (int r = 0;r < MAZE_SIZE; r++) {
		for (int c = 0; c < MAZE_SIZE; c++) {
			printf("%c", maze[r][c]);
		}
		printf("\n");
	}
}

int main() {
	int r, c;
	StackType s;

	init_stack(&s);
	here = entry;
	while (maze[here.r][here.c] != 'x') { //현재 위치가 목적지일때 까지, 
		r = here.r;
		c = here.c;
		maze[r][c] = '.';
		maze_print(maze);
		push_loc(&s, r - 1, c); 
		push_loc(&s, r + 1, c);
		push_loc(&s, r, c - 1);
		push_loc(&s, r, c + 1); //위치 기준 4방향 으로 push_loc하는 것이다. 단, 항상 순서는 동일하게, 상하좌우로. 
		//그러면 스택에 쌓일때, 모든 방향이 갈 수 있음을 전제로 할때, 무조건 pop()을 한다면 우좌하상으로 가는 것이다.

		if (is_empty(&s)) { //스택이 비었을 경우 갈 곳이 없는, 즉 목적지로 못 가는 미로인것이다.
			printf("실패\n");
			return;
		}
		else
			here = pop(&s); 
		//현재 위치 기준의 되는 방향의 스택을 모두 저장한뒤, pop으로 스택의 맨위를 빼내온다. 다음 반복문에서는 그 좌표로 이동하여, 현재위치가 되며, 그 위치를 토대로 조사하게 된다.
		//만약 4방향으로 조사하였는데, 예를 들어 상, 우 방향 이상 갈 수 있다 하더라도, 
		//스택으로 모두 순차적으로 저장한 후, 스택에서 빼내어 우으로 간후, 그 위치 기점, 모든 방향 push_loc가 막힌다면, 최근의 가장 가까운 다른 경로인 원래 위치로부터의 상 방향이 이제 다음 위치가 되는거다.
	}
}
