빅오 표기법 및 시간 복잡도.

우선 n이 무엇인지 코드 내에서 잡는 것이 1순위.
이후

1) 반복문 횟수. 총 몇번 도는가?
- 단일 반복문 -
for (int i = 0; i<n; i++);

while(n>0){
  n--;
}
두 경우다 n번 실행되므로 O(n)

- 중첩 반복문-
각 반복문에 있어서, 반복 횟수만큼 서로 곱한다.
for (int i = 0; i<n; i++){
  for (int j = 0; i<n; j++){
    printf("%d", i);
  }

n*n = O(n^2)

for (int i = 0; i<n; i++){
  for(int j = 0; j<m; j++){
    ...
  }
}
n*m = O(nm)

2) 반복횟수가 마치 절반 씩 계속 줄어든다면, log n 꼴이다.
while(n>1){
  n = n/2;
}
이 경우에 n은 n/2, n/4, n/8 이런식으로 되기에,
시간복잡도는 O(log n) 이다.

3) if 문은 상수 시간복잡도. 한번만 확인하므로 O(1) 이다.
4) 코드가 여러개가 있을떄, 구한후 이내 복잡도 끼리 더한다. 그리고 다시 빅오 표기법으로 정리한다.
예를 들어 어느 코드에 이중반복문과 단일 반복문 코드가 연달아 나온다고 하면 O(n^2), O(n) = O(n^2 + n) = O(n^2) 이런식으로다.
  
5) 재귀함수에 대해서.
항상 재귀함수의 시간복잡도를 생각할떄는, 몇번 호출을 하는지와, 그 과정에 대해서 봐야한다.

void f(int n) {
    for (int i = 0; i < n; i++) {  //단일 반복문 O(n)
        printf("*");
    }
    f(n - 1); //이로써 재귀 호출은 총 n번.
}
따라서 이 코드의 시간 복잡도는. 재귀호출 n번과 그 호출마다의 반복문 n, n-1, n-2... 의 합.
n(n+1)/2 -> O(n^2) 이다.
재귀 호출마다의 for 문에 대해 범위가 줄어들 경우 합으로 계산하는것이 안전하다. 

void f(int n) {
    if (n <= 1) return;
    f(n / 2);
}
이 경우에는 안의 if문은 O(1) 에, f(n/2) 의 호출로 즉 계속 반복 횟수를 반씩 줄어들고 있다.
즉 이 코드의 시간 복잡도는 O(log n) 이다. 
