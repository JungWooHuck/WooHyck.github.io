//이진 탐색트리
//탐색은 레코드의 집합에서 특정한 레코드를 찾아내는 작업을 의미한다.
//한 레코드는 하나 이상의 필드로 구성되어 있으며, 여러 레코드가 모여 있는 집합을 테이블이라고 한다. 또한 이런 레코드들을 식별하는 값을 키라고 부르며, 레코드 별 모두 각각의 고유한 키를 주요 키라고 부른다.

//이진 탐색트리는 이러한 정의이다.
//모든 원소의 키는 유일한 키를 가진다, 한쪽 서브 트리 키들은 루트 키보다 작으며, 오른쪽 서브트리의 키들은 루트의 키보다 크다. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.
//따라서 찾고자 하는 키의 값이 이진트리의 루트노드의 키의 값과 비교하여 낮으면 왼쪽 서브트리, 높으면 오른쪽 서브트리 등으로 탐색을 한다.
//그런식으로 반복하다가 키가 같으면 탐색이 성공 적으로 완료 되는 것이다.

#include <stdio.h>
#include <stdlib.h>

typedef int element;
typedef struct TreeNode {
	element key;
	struct TreeNode* left, *right;
}TreeNode;

//순환적인 탐색 함수
TreeNode* search(TreeNode* node, int key) {
	if (node == NULL) return NULL; //이 경우는 탐색을 계속 하였으나 단말노드를 지나 NULL이 된 즉 탐색 실패의 경우이다.
	if (key == node->key) return node; //탐색 성공
	else if (key < node->key)
		return search(node->left, key); //찾으려는 키가 현재 보고있는 노드의 키보다 작아야 한다면 왼쪽으로. 한번더
	else
		return search(node->right, key);
}

TreeNode* new_node(int item) {
	TreeNode* temp = (TreeNode*)malloc(sizeof(TreeNode));
	temp->key = item;
	temp->left = temp->right = NULL;
	return temp;
}

TreeNode* insert_node(TreeNode* node, int key) { 
	//이진탐색트리에서의 삽입 연산은 반드시 탐색을 행하야한다. 이때 새로운 노드는 항상 단말 노드에 추가된다.
	//또한 신경써야 할 것이 있다. 이진 탐색트리에서의 키 값은 고유해야 하므로, 오히려 탐색에 성공한다면 중복이므로 삽입이 불가능하며, 탐색에 실패한다면 삽입이 가능하거니와, 탐색에 최종적으로 실패한 그 자리가 삽입 자리가 된다.
	if (node == NULL) return new_node(key); // 트리가 공백이라면 새로운 노드를 반환한다.

	if (key < node->key)
		node->left = insert_node(node->left, key); //아닐 경우, 순환호출을 이용하며, 게속 트리를 내려가며 탐색한다.
	else if (key > node->key)
		node->right = insert_node(node->right, key);

	return node; //루트 포인터를 반환한다. 

	//차근차근 보자. 우선 노드를 표현할때, 전제로 예를 들어 [1, 2, 3] 의 표기라면 []는 하나의 노드를 뜻하며 left 와 right 링크 필드는 1,3 즉 다른 노드를 가르키는 것이고, 데이터는 2 이다.
	//			3
	//		1		4
	//이런 이진탐색트리가 있다고 치자. key= 5 로 할 것이며 트리의 루트부터 시작을 한다.
	// 노드 [1, 3, 4] 의 상황에서, node->right = insert_node(4,5); 으로 호출한다. 이제 4의 노드를 보자. [NULL, 4, NULL] 이다. 그리고 한번더 node->right = insert_node(NULL, 5); 으로 하고 있다.
	//이후  node == NULL 탐색 실패 상황이므로 new_node으로 인하여 하나의 새로운 노드를 생성한다. 
	//			3
	//		1		4
	//					5

	//저런 꼴이 될것이다. 이제 하나하나씩 반환을 다시 해보자. node->right = 노드 5 가 되어, 이제 [NULL, 4, 5] 가 된다. 한번더 돌아가서 node->right = insert_node(4,5)에 의하여 [1,3,4] 으로 된다.
	//([1,3,4] 자체는 바뀌지 않았지만, 4의 데이터를 가진 노드의 오른쪽 링크 필드가 바뀐 새로운 노드로 바뀌었다)
}

TreeNode* min_value_node(TreeNode* node) {
	TreeNode* current = node;

	while (current->left != NULL)
		current = current->left;

	return current;
}

TreeNode* delete_node(TreeNode* root, int key) {
	//삭제 연산도 탐색을 기본으로 연산하지만, 삭제의 경우에는 세가지로 분류하여 봐야 한다. 
	//1. 삭제하려는 노드가 단말 노드일 경우  2. 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리중 하나만 가지고 있는 경우  3. 삭제하려는 노드가 두개의 서브트리 모두 가지고 있는 경우

	if (root == NULL) return root;

	if (key < root->key)
		root->left = delete_node(root->left, key);
	else if (key > root->key)
		root->right = delete_node(root->right, key);

	else {
		//탐색을 성공적으로 마치고 이제 노드를 삭제할 차례이다.
		//1번과 2번의 경우에는 간단하다. 1번의 경우에는 단말노드이기에 말 그대로 단말 노드만 지우면 된다. 2번의 경우에는 그 노드를 삭제하고 그 노드의 서브트리를 삭제한 노드의 부모 노드에 붙여주면 된다.
		if (root->left == NULL) { //삭제하려는 노드가 오른쪽 서브트리만 있는 경우이다.
			TreeNode* temp = root->right;
			free(root);
			return temp; 
		}
		else if (root->right == NULL) {// 이 경우는 왼쪽 서브트리만 존재할 경우
			TreeNode* temp = root->left;
			free(root);
			return temp;
		}
		//의문점: temp를 부모노드에 붙여주는 코드는 없지 않은가..?
		//답:아니다 잘 보자. 탐색을 마친후에 이 과정을 한것이지, 이후 반환되고 나서는 if (key < root->key)root->left = delete_node(root->left, key); else if (key > root->key)root->right = delete_node(root->right, key);
		//저 코드로 다시 돌아가게 될 것이다.  그러면 자연스래 부모 노드에 후계자 노드가 연결될 것이다. 
			
		//아래는 3번의 경우이다. 3번의 경우 무작정 아무 노드나 붙여주면 안된다.  이 경우에는 최대한 삭제되는 노드와 가장 값이 비슷한 노드를 후계자로 선택한다.
		//이는 왼쪽 서브트리에서 가장 큰 값, 즉 가장 오른쪽에 있는 값이며, 오른쪽 서브트리는 반대로 가장 작은 값, 즉 가장 왼쪽에 있는 값이다.
		//둘 중 아무거나 해도 상관이 없기에, min_value_node 함수에 맞춰서 즉 오른쪽 서브트리에서 맨 왼쪽 단말 노드를 하는 것으로 전제한다.
		
		TreeNode* temp = min_value_node(root->right); //이제 temp는 루트 기준 삭제하려는 루트 기준 오른쪽 서브트리의 맨 왼쪽 노드로 저장된다.

		root->key = temp->key; //이제 후계 노드를 복사한다.
		root->right = delete_node(root->right, temp->key); //원래 있엇던 후계 노드는 삭제시킨다. 단, 물론 기껏 복사해놓은 root는 지우면 안되기에 root->right 부터 시작하게 한다. 
		
	}
	return root;
}

void inorder(TreeNode* root) {//중위 순회
	if (root) {
		inorder(root->left);
		printf("[%d] ", root->key);
		inorder(root->right);
	}
}

int main() {
	TreeNode* root = NULL;
	TreeNode* tmp = NULL;

	root = insert_node(root, 30);
	root = insert_node(root, 20);
	root = insert_node(root, 10);
	root = insert_node(root, 40);
	root = insert_node(root, 50);
	root = insert_node(root, 60);

	printf("이진 탐색 트리 중위 순회 결과 \n");
	inorder(root);
	printf("\n\n");
	if (search(root, 30) != NULL)
		printf("이진 탐색 트리에서 30을 발견함 \n");
	else
		printf("이진 탐색 트리에서 30을 발견못함");
	return 0;
}
