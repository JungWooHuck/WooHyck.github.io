#include <stdio.h>
#include <stdlib.h>
//원형 연결리스트는 단일 연결 리스트와 다르게, 말 그대로 끝이 NULL을 가르키는 것이 아닌, 끝 노드의 링크필디가 첫번째 노드를 다시 가르키게 되는 구조이다.
//단일 연결리스트와 비교하여, 하나의 노드에서 다른 모든 노드로의 접근이 가능하며, 노드 삽입, 삭제가 더 용이하다는 장점이 있다.
typedef int element;
typedef struct ListNode {
	element data;
	struct ListNode* link;
}ListNode;

void print_list(ListNode* head) {
	if (head == NULL) return;
	ListNode* p = head->link;
	do {
		printf("%d->", p->data);
		p = p->link;
	} while (p != head->link);  // 한 바퀴 돌면 종료
	//의문점: 왜 while문이 아닌 do-while문을 책에서는 써야한다고 하는 것인가?
	//답: 원형리스트는 NULL이 없기 때문이다. 예컨데, 최소 1개 노드가 반드시 존재하기 때문이라 봐도 된다.
}

void free_list(ListNode* head) {
	if (head == NULL)return;
	for (ListNode* p = head->link, *temp; p != head; free(temp)) //초기식 ListNode* p = head->link, *temp;, *temp; 의 경우에는  ListNode* p = head->link; 와 ListNode *temp; 으로 두 변수 선언과 같은 뜻이다.
		temp = p, p= p->link;
	free(head); //순회하면서 전체 원형 연결리스트를 해제시키는 것이다.
}

ListNode* insert_first(ListNode* head, element data) {
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	node->data = data;
	if (head == NULL) {
		head = node;
		node->link = head;
	}
	else {
		node->link = head->link; //첫번째 노드가 될 노드의 link를 head의 link로 대입시킨다.
		//예컨대 원래 a => b  이런 연결 리스트가 있다고 하자, 그러면 head는 b를 가르킬 것이고, head->link 는 a를 가르킬것이다. 우리가 원하는 것은 node => a => b 이다.
		//그렇기에 node->link 는  a를 가르켜야 하므로, head->link를 대입시키고, 이후 규칙에 따라서 head는 b, head->link 는 node를 가르키게 되야한다.
		
		head->link = node;
		//기억하자. 원형 연결리스트에서는 마지막노드를 head로 둔다. 그러면 head->link 는 자연히 첫번째 노드가 되는 것이다.
	}
	return head; 
}

ListNode* insert_last(ListNode* head, element data) {
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));
	node->data = data;
	if (head == NULL) {
		head = node;
		node->link = head;
	}
	else {
		node->link = head->link; //원형리스트는 어찌보면 어느 노드의 링크필드가 NULL인 노드가 없기에, 어느 노드가 처음이고 끝인지가 불분명하다.
		head->link = node; // head가 가르키고 있는 노드의 link를 node로 변경
		head = node; //즉 이러한 점을 이용하여, 그냥 head포인터를 움직여 마지막 노드를 정하는 것이다.
	} 
	return head;
}
//다시 기억하자. head는 연결리스트의 어떤 노드를 가리키는 포인터 변수이며, 가리키는 노드를 바꿀 수도 있고, 그 노드의 내부 데이터(link, data)를 직접 수정할 수도 있다.
int main() {
	ListNode* head = NULL;

	head = insert_first(head, 10);
	head = insert_last(head, 20);
	head = insert_last(head, 30);
	head = insert_last(head, 40);

	print_list(head);
	free_list(head);
	return 0;
}
// 이때 원형리스트는 단일리스트와 중간의 노드 삽입/삭제 방법은 모두 같기에 생략하였다. 마찬가지로, "접근 하려는 선행 노드 / link를 어떻게 바꿀것인가" 만 신경쓰면 된다.
