//그래프는 객체사이의 연결 관계를 표현할 수 있는 자료구조이다.
//여러 가지 특성을 가질수 있는 객체를 정점(vertex) 혹은 노드라고 부르며, 이러한 정점들의 관계를 의미하는 것을 링크(link) 혹은 간선(edge) 이라고 부른다.
//그래프의 간선은 방향을 가지는 혹은 무방향이 있으며, 또 간선에 가중치를 부여하며 가중 그래프라고 부른다. 간혹 네트워크라고도 부른다.
//그래프중 하나의 정점의 차수는 정점에 연결되어 있는 간선의 수와 같으며, 한 그래프의 모든 정점의 차수 합은 간선의 수 * 2 와 같다.
//그래프의 표현법은 인접행렬(2차원 배열 표현), 인접리스트(연결리스트 표현) 으로 나뉘어 진다.

//먼저 인접행렬을 보자. 하나의 그래프에는 정점의 수 n과 n*n 2차원 배열 인접행렬 M의 정보가 있다. 이때, 이러한 과정에서 간선이 존재시 1, 존재하지 않는다면 0을 저장한다.

//규칙이 몇가지 있다. 우선 전체적으로 그래프에는 자기자신을 가르키는 간선은 없으므로 2차원 배열 기준 오른대각 아래(인접행렬의 주대각선(M[i][i]))는 모두 0이 된다.
//또한 만약 무방향 그래프인 경우에는 그 오른대각 기준 대칭이 된다.
//n개 정점그래프라고 치자. 인접행렬로 표현하였을 경우 간선의 수와 무관하게 항상 n^2개의 메모리가 필요하다. 따라서 간접이 많이 있는 밀집 그래프에서는 상대적으로 적합하고, 적은 숫자의 간선 그래프인 희소 그래프에서는 부적합하다.
//또한 시간 복잡도를 보자. 만약 두 정점간의 간선 유무를 알고 싶다면 단순 M[u][v] 인덱스를 조사하면 된다. 즉 O(1) 이다. 정점의 차수를 알고 싶으면 행 혹은 열을 조사하면 되기에 O(n)이다.
//그러나 모든 간선의 수를 구하기 위해서는 이차원 배열의 모든 행렬을 전체 조사해야 하므로, O(n^2) 의 시간 복잡도가 된다.

#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 50
typedef struct GraphType {
	int n; //정점의 개수
	int adj_mat[MAX_VERTICES][MAX_VERTICES];
}GraphType;

void init(GraphType* g) {
	int r, c;
	g->n = 0;
	for (r = 0; r < MAX_VERTICES; r++)
		for (c = 0; c < MAX_VERTICES; c++)
			g->adj_mat[r][c] = 0;;  //그래프 생성 및 초기화
}

void insert_vertex(GraphType* g, int v) { //정점 삽입 연산
	if (((g->n) + 1) > MAX_VERTICES) {
		fprintf(stderr, "그래프: 정점의 개수 초과");
		return;
	}
	g->n++; //정점을 삽입하는 연산은 n을 하나 증가하기만 하면 된다.
	//의문점: ...이렇게 간단한건가..? 정점이 하나 추가 된다는 것은, 행 혹은 열이 하나 증가한다는 소리 아니였나..?
	//답: 이미 init에서는 정점의 개수와는 상관없이 MAX_VERTICES  * MAX_VERTICES 크기의 배열 만큼을 0으로 초기화 시켰었다. 즉 n을 증가시키고 나서, 어차피 간선 삽입 연산이나 출력연산을 할 것이기에 동시에 상관 없다.
}

void insert_edge(GraphType* g, int start, int end) { //간선 삽입 연산. 이 경우에는 대응되는 인덱스에 대입하면 쉽다.
	if (start >= g->n || end >= g->n) {
		fprintf(stderr, "그래프: 정점 번호 오류");
		return;
	}
	g->adj_mat[start][end] = 1;
	g->adj_mat[end][start] = 1;   //무방향 그래프에서만 성립한다.
}

void print_adj_mat(GraphType* g) {
	for (int i = 0; i < g->n; i++) {
		for (int j = 0; j < g->n; j++) {
			printf("%2d ", g->adj_mat[i][j]);
		}
		printf("\n");
	}
}

int main() {
	GraphType* g;
	g = (GraphType*)malloc(sizeof(GraphType));
	init(g);
	for (int i = 0; i < 4; i++)
		insert_vertex(g, i);
	insert_edge(g, 0, 1);
	insert_edge(g, 0, 2);
	insert_edge(g, 0, 3);
	insert_edge(g, 1, 2);
	insert_edge(g, 2, 3);
	print_adj_mat(g);

	free(g);
}
