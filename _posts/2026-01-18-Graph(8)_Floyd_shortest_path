//Floyd의 최단 경로 알고리즘
//그래프에 존재하는 최단 경로를 모두 구하려면 Dijkstra의 알고리즘을 정점의 수 만큼 반복실행하면 된다. 그러나, 모든 정점 사이의 최단거리를 구하려면 더 간단한 알고리즘이 존재한다.
//이 알고리즘은 2차원 배열 A를 이용하여 3중 반복을 하는 루프로 구성되어있다. 우선 인접 행렬 weight의 기준 2차원 배열이면 i==j 인 경우는, 저번에 말했듯이 자체 간선은 없으므로 weight[i][j] = 0 으로 모두 저장한다.
//만약 두개의 정점 i와 j 사이의 간선이 존재하지 않는다면 무한으로 요소를 저장한다고 치자. 존재한다면 그 요소의 값은 가중치가 된다.

//조금 말로는 설명하는데 어려울 수 있다. 이 알고리즘은 우선 어느 정점이든 출발이 될 수 있고, 어느 정점이든 도착이 될 수있다(자기자신빼고) 그것을 모두 표현하는 것이라고 가정하자.
//예컨대 가중치를 초기로 2차원 배열에 모두 저장했다고 치자. 모든 정점을 기준으로 이제 행과 열이 있을때, 편의상으로 행의 인덱스를 출발 정점, 열의 숫자를 가고자 하는 도착 정점이라 생각하자.
//어느 한 행을 임의로 기준으로 보았을때, 그 한 행에 있는 요소들은 가중치가 있는 것도, 혹은 무한인 것도 있을 것이다. 생각하자. '시작 초기배열 값은 그 행의 인덱스(출발지 정점) 기준으로 열의 요소 값이 있을 것이다. 
//예컨데 0번째 인덱스 행을 본다면 0 번호 정점과 직접 간선으로 이어져 있지 않은 정점은 무한대, 간선으로 이어져 있는 곳은 가중치가 적혀 있을 것이다.
//이제 Dijkstra와 비슷하다. 출발지로부터 어디를 거쳐서 가는 경로가 원래 경로보다 가중치가 적다면 바꾸는 것이다. 다른 점이라고는 모든 행에 모든 열에 적용하는 것이다.
//그럼 어떻게 될까, 3x3 행렬이라고 치자, 0, 1, 2 번째 행은 모두 각각 정점 0을 거쳐서 가는 경로, 정점 1을 거쳐서 가는경로, 정점 2를 거쳐서 가는 경로를 각 자신의 행의 열(도착지 정점) 에 맞춰서 보거니와 가중치를 보고 갱신하거나 유지하거나를 반복할 것이다.
//즉  어떠한 정점(마치 행의 인덱스) 를 중간 경유지로 허용했을 때 i → j가 더 짧아지는가 를 반복해서 검사한다.

//쉽게 생각하자. 그럼 이렇게 된다. 정점수 n개 (n반복) * 행(n) 반복 * 열(n)에 대하여 조사 반복. 즉 시간 복잡도는 O(n^3)이 된다.

//의문점: 저 알고리즘은 중간 경유지를 무조건 인덱스 오름차순 순서대로 중첩하여 보게 되기에 정말 최단 경로로 되는게 맞는가? 예컨대
//중간 경유지를 0 → 1 → 2 → … → n - 1 이렇게 순서대로만 허용하는데, 만약 최단 경로가 (5 → 2 → 8) 이런 순서면 순서가 꼬여서 못 찾는 거 아닌가 ?

//답: 아니다. 경로의 ‘순서’를 찾는 알고리즘이 아니다. “허용된 중간 정점의 집합”을 점점 늘려가는 알고리즘이다.
//조금 더 생각해보자 distance[i][j] 는 i에서 j라는 정점까지 가는데의 최소 비용이다. 자 봐보자. k = 0일때 조사하는 것은 정점 0을 중간으로 써도 되는 경우까지 고려한 최단 거리이다. 
//k = 1으로 될때 조사하는 것은 정점 1만이 아닌, 정점 0,1을 중간에 아무 순서로 써도 된다는 소리다.
//그러니까 k=5차례가 왔다고 치자. 중간 정점으로 쓸수 있는 집합은 {0,1,2,3,4,5} 이 되는 것으로 0 3 2 이런식으로 가든, 0 4 5 이런식으로 가든 상관이 없다는 거다. 

//추가 의문점: 0 부터 정점 수만큼 계속 k를 증가 하거니와 이제 계속 반복하여 중간에 순서를 뒤죽박죽하든 안쓰든 그건 상관을 안한다는거 아닌가? 
//하지만 이게 맞다면 왜 처음에 0 혹은 0,1 이런식으로 제한해서 봐야하는가? 그냥 전체 0,1,2,3,4 모두 가능하게 하서 처음부터 보면 되는거 아닌가?

//답: 그냥 사람이 풀면 그냥 한번에 모든 것을 허용하거니와, 모든 결과 경로를 계산한후 비교하면 되겠지만 알고리즘은 거의 불가능하다.
//간단하게 보자. distance는 계속 바뀔 것이다. 그 상태에서 아직 확정적으로 정해지지 않은 값을 다시 비교대상으로 사용하는 것으로 꼬인다.

#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0 
#define MAX_VERTICES 100
#define INF 1000000

typedef struct GraphType {
	int n;
	int weight[MAX_VERTICES][MAX_VERTICES];
}GraphType;

int A[MAX_VERTICES][MAX_VERTICES];

void printA(GraphType* g) {
	int i, j;
	printf("====================================\n");
	for (i = 0; i < g->n; i++) {
		for (j = 0; j < g->n; j++) {
			if (A[i][j] == INF)
				printf(" * ");
			else printf("%3d ", A[i][j]);
		}
		printf("\n");
	}
	printf("====================================\n");
}

void floyd(GraphType* g) {
	int i, j, k;
	for (i = 0; i < g->n; i++)
		for (j = 0; j < g->n; j++)
			A[i][j] = g->weight[i][j];
	printA(g);

	for (k = 0; k < g->n; k++) {
		for (i = 0; i < g->n; i++)
			for (j = 0; j < g->n; j++)
				if (A[i][k] + A[k][j] < A[i][j]) //k가 중간 지점이다. i부터 k거리 + k부터 j거리 < i부터 j거리 이리 봐도 된다. (거리는 가중치, 간선을 내포한다)
					A[i][j] = A[i][k] + A[k][j];
		printA(g);  
	}
}
//Floyd의 3중 반복은‘경로를 탐색하는 반복’이 아니라 허용된 중간 정점의 집합을 하나씩 늘리는 DP 정의’다.

int main() {
	GraphType g = { 7,
		{{0,7,INF,INF,3,10,INF},
		{7,0,4,10,2,6,INF},
		{INF,4,0,2,INF,INF,INF},
		{INF,10,2,0,11,9,4},
		{3,2,INF,11,0,INF,5},
		{10,6,INF,9,INF,0,INF},
		{INF,INF,INF,4,5,INF,0}}
	};
	floyd(&g);
	return 0;
}
