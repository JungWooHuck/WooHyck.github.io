배열응용: 다항식

#include <stdio.h>
#define MAX(a,b) (((a)>(b))?(a):(b)) // 비교 삼항 연산자.
#define MAX_DEGREE 101

typedef struct {
	int degree; //최대 차수 저장
	float coef[MAX_DEGREE]; //각 항의 계수 저장 배열
}polynomial;

polynomial poly_add1(polynomial A, polynomial B) {
	polynomial C;  //결과 다항식
	int Apos = 0, Bpos = 0, Cpos = 0; //배열의 인덱스 변수
	int degree_a = A.degree; //A와 B도 우선은 polynomial 구조체의 변수 매개변수로 쓴 후, 각 구조체의 멤버인 degree(최대차수) 를 저장함.
	int degree_b = B.degree;

	C.degree = MAX(A.degree, B.degree); //C.degree 는 이 A와 B중 큰 최대 차수 저장.

	while (Apos <= A.degree && Bpos <= B.degree) {  //Apos 와 Bpos 모두 배열의 인덱스 변수, 여기서는 차수와 같은 뜻. 이때 상수항은 0.
		//어떠한 배열의 A or B pos 가 각각의 방정식 모두 degree에 비해 커질때서야 반복을 멈춤.
		if (degree_a > degree_b) { 
			C.coef[Cpos++] = A.coef[Apos++]; 
			degree_a--; 
		}
		else if (degree_a == degree_b) {
			C.coef[Cpos++] = A.coef[Apos++] + B.coef[Bpos++];
			degree_a--;
			degree_b--;
		}
		else {
			C.coef[Cpos++] = B.coef[Bpos++];
			degree_b--;
		}
	}
	return C;

}
void print_poly(polynomial p) {
	for (int i = p.degree; i > 0; i--)
		printf("%3.1fx^%d + ", p.coef[p.degree - i], i); //p.coef[p.degree - i] 는 방정식이 출력될떄 최고차항부터 출력되도록 한다.
	printf("3.1f \n", p.coef[p.degree]);
}

int main() {
	polynomial a = { 5,{3,6,0,0,0,10} };
	polynomial b = { 4,{7,0,5,0,1} };
	polynomial c;

	print_poly(a);
	print_poly(b);
	c = poly_add1(a, b);
	printf("---------------------------------------------------------------------------------------------\n");
	print_poly(c);
	return 0;
}

---------------설명--------------------
우선 코드를 보자. 코드는 두 다항식의 연산 중 덧셈을 구현한 것이다.
각 다항식에 대해서 구조체 polynomial의 변수로 선언하며, 구조체 내부의 구현에 대해서는 다항식의 최대차수는 degree, 각 항의 계수는 배열 coef 으로 하였다.
(이때, 계수가 큰 순서대로 인덱스 0부터 차례대로 저장하며, 0인 계수는 생략하지 않는다)
코드 이해를 쉽게 하기 위해 예제의 main() 함수의 
polynomial a = { 5,{3,6,0,0,0,10} };
polynomial b = { 4,{7,0,5,0,1} }; 기준으로 설명하겠다.
이럴 경우 우선 C.degree = MAX(A.degree, B.degree); 에 의해 확정적으로 C.degree(최대 차수) 는 5이다.
int Apos = 0, Bpos = 0, Cpos = 0; 인 상황에서 while (Apos <= A.degree && Bpos <= B.degree) 조건을 달았다. A,B,Cpos 의 경우는 배열을 순회하는 current index (현재 가르키고 있는 차수) 라고 봐도 된다.
일단은 if (degree_a > degree_b) { 
			C.coef[Cpos++] = A.coef[Apos++]; 
			degree_a--; 
		} 에 바로 조건식이 부합하므로 이를 따른다.
그러면 C.coef[0] = A.coef[0] 이 된 이후, Cpos 와 Apos 모두 +1, 이후 degree_a--; 가 된다.
이게 무슨 뜻이냐면, 여기서 구조체의 차수를 저장한 배열은 최대차수부터 저장 하였다. 그러니 만약 A와 B중 어느 배열 degree가 높다면 덧셈을 해도 그 항에 대해서는 차수가 높은 항의 계수가 될 수 밖에 없을거다.
이후 current index인 pos 를 C와 A를 증가 시켜, A의 경우에는 인덱스에 따라 6을, 즉 4차항을 가르키게 된다. 그리고, 5차항의 계산을 끝냇으므로 이제 계산에서의 논외 대상이므로, degree_a-- 를 시킨거다.

이후에는 계속 else if (degree_a == degree_b) {
			C.coef[Cpos++] = A.coef[Apos++] + B.coef[Bpos++];
			degree_a--;
			degree_b--;
} 를 따른다. 
의문점: 이후 Apos 와 Bpos 모두 각 degree에 대해 커질 경우에 반복을 종료하는데, 각 pos는 +1를 하고, 각 degree는 -1 되는 셈인데, 이게 의도와는 다르게, 순회를 전부다 못하는 게 아닌 이유..? 엄연히 2씩 가까워 지는것 아닌가?
//답: 햇갈리지말자. pos는 어디를 읽는가이고, degree는 현재 비교 중인 차수를 나타내는 변수이다.
//그리고 다시 봐라 while 조건문의 A.degree는 반복문 안에서 변화하는 degree_a와 아무 상관이 없다. 처음 초반 코드에서 같은 값으로 대입시켰을 뿐이다. 한번도 A.dgree는 변한 적 없다.
//간단하다. b=0; a=b; b=b+1; 이렇게 했다고 치면, a는 1이 아니라, 상관없이 계속 0이다.
//즉 다시 말하자면 A.degree는 그냥 A의 최고 차항(고정값, 배열 길이)를, degree_a는 현재 비교중인 최고차항을 뜻한다고 봐도 된다.

