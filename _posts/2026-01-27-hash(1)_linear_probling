//해싱
//해싱은 key에 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근한다.
//이렇게 키에 대한 연산에 의하여 접근이 가능한 구조를 해시 테이블이라고 한다. 

//이렇게 생각하자. 우선 key:value 으로 쌍을 짓거니와,  100명의 직원들에 있어서 0부터 99개의 아이디를 (키를)	부여하고 100의 크기의 배열을 만든다. 즉 key는 마치 인덱스로 생각되어지는 것이다.
//그러나 현실적으로 탐색 키들이 문자열이거나 매우 큰 숫자일 경우가 대다수 이므로, 각 탐색키를 작은 정수로 매핑시키는 어떤 함수가 필요하다.

//다시 보자. 해싱이란 어떤 항목의 키만을 가지고 항목이 들어있는 배열의 인덱스를 결정하는 것이다. 해시 함수는 키를 입력으로 받아서 해시주소를 생성하고, 이 해시주소를 해시테이블의 인덱스로 사용한다.
//예를 들어 영어단어를 입력했다면, 그 단어가 키가 되고, 이 단어를 해싱 함수를 이용하여 적절한 작은 정수 i로 변환한 다음에, 배열의 arr[i] 에 그 단어의 정의(값)을 저장하는 것이다.
//각 테이블은 인덱스마다, 버킷으로 이루어져 있으며, 이 버킷은 여러개의 슬롯을 가질 수 있다.

//이렇게 여러개의 슬롯을 갖는 이유는 이것이다. 어찌되었든 키보다, 버킷의 수가 상대적으로 매우 작을것이다. 즉 여러개의 서로 다른 키가 해시 함수에 의해 같은 해시 주소로 매핑되는 경우가 발생할 것이다.
//이것을 충돌이라 하고, 이 충돌된 서로다른 키들을 저장하기위해, 슬롯이 있는 것이다. 각 슬롯에서는 한 항목만 저장이 되기에, 각자 따로 다른 슬롯에 저장된다. 이때의 키들을 동의어라 한다.

//만약 이런 충돌이 버킷에 할당된 슬롯수보다 많이 발생하게 되면 오버플로우가 발생하게 된다. 만약 버킷 하나 당 슬롯의 수가 하나면 충돌이 곧 오버플로우를 의미한다.
//이런 것을 해결하기 위해, 해시함수를 수정하거나, 테이블의 크기를 조절하는 등이 필요하다.

//이상적인 해싱
//예를 들어보자. 해싱 테이블에는 학생들의 여러 인적사항이 저장되어 있고, 학번을 키로 가정하자. 학번은 5자리로 되어있고, 앞의 2개의 숫자는 학과를 나타내고, 뒤의 3자리 숫자가 각 학과의 학생들의 번호이라고 가정하자.
//만약 같은 학과 학생들만 저장한다고 가정하면 키의 뒤 3자리만 사용하면 된다. 즉 이때의 해시함수는 단순히 5개의 숫자 중에서 뒤의 3자리만 추출시키는 함수가 될 것이다.
//h(01023) = 23 이런 꼴이 되는 것이다. 이 경우에 해시 테이블에 자료를 저장하거나 꺼내거나 탐색하는데에 시간은 O(1) 이다. 즉 해시 함수를 계산하는 시간만 필요하다. 이처럼 매우 빠르다.

//실제로는 해시 테이블의 크기가 제한되어 있고, 키는 매우 많다. 그래서 일반적의 경우에는 키에 비하여 해시 테이블의 크기가 작다. 슬롯이 많을 뿐이다.
//하지만 또 키 중에서 일부만 사용된다. 전부 다 사용되는 것이 아닌 경우가 일반적이다. 즉 전체를 위한 공간을 항상 준비할 필요가 없다.
//간단한 방법이 있다. 키를 해시테이블의 크기로 나누어서 그 나머지를 해시 테이블의 주소로 하는 것이다.

//정수 i를 테이블 크기 M으로 나눈 나머지를 취하면 0에서 m-1 이 나오고, 이를 인덱스로 쓰는 것이다.
// h(k) = k mod M 이라 하자. (mod는 나머지를 구하는 연산자)

//저런 경우에는 하지만 항상 충돌과 오버플로우가 빈번하게 일어날 수 있다. 즉 복잡도가 O(1)의 경우보다 더 떨어지는 경우가 대부분이다.

//해시함수에 대해서 이제 자세하게 보자. 해시 함수는 이럴수록 좋다. 1. 충돌이 적어야 한다. 2. 해시함수 값이 해시테이블의 주소 영역 내에서 고르게 분포되어야 한다. 3. 계산 자체가 빨라야 한다.

/*
1) 제산 함수
제산함수는 나머지 연산자 mod를 이용하여 키를 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법이다. 아까 봤던 h(k) = k mod M 와 같다.
테이블의 크기인 M은 주로 소수로 선택한다.
이 방법은 고르게 분포한다는 점에서 큰 이점이 있다.
M이 왜 소수가 좋은지 보자. 예를 들어 M이 짝수라면 k mod M 은 k가 짝수라면 짝수가 되고, k가 홀수라면 홀수가 된다. 만약 메모리 주소가 보통 2의 배수라는 것을 생각하고, 메모리 주소를 대상으로 해싱을 한다면, 짝수가 될 확률이 매우 높아서, 편향되어진다.

반대로 소수로 선택하였을 경우 자기 자신과 1만을 약수로 가지는 수이기에, 골고루 분포하여 값을 만들어 낸다.
...그리고 mod 와 %연산자는 다르다. 예컨대 a mod n 의 경우에는 항상 0부터 n-1 까지의 값만이 나오게 한다.
하지만 a % b 또한 비슷하나, a의 부호를 따라가게 된다. 즉 음수의 결과가 나올 수 있는 것이다.. 즉 이를 고려하여 제산 함수를 짜야 한다.
이제 코드를 보자

int hash_function(int key){
	int hash_index = key % M; //해시 인덱스 설정
	if (hash_index < 0)
		hash_index += M;
	return hash_index;
} 
예를 들어보자 key = -23이라고 가정하고, 테이블 크기는 10이라고 치자. 연산시 hash_index = -23 % 10 = -3 이렇게 된다. 즉 이런 것을 방지하기 위해 양수로 만들고, 동시에 0~M-1 의 범위를 지켜야 하므로, M을 더한다.
*/

/*
2) 폴딩 함수
주로 키가 해시 테이블의 크기보다 더 큰 정수일 경우에 사용된다.
예를 들어 키는 32비트이고, 해시 테이블의 인덱스는 16비트 정수인 경우다. 
그렇다면 테이블의 크기로 나눠본다고 치자. key에 있어서 여럿 자리수에 있어서 하위비트만 강하게 반영되고, 상위 비트는 거의 반영이 안되게 된다.
키의 일부만을 사용하는 것이 아닌 키를 몇ㅊ개의 부분으로 나누어 더하거나나, 비트별로 XOR같은 부울 연산을 하는 것이 좋은 방법이다.
예를 들어 32비트 키를 2개의 16비트로 나누어 비트별로 XOR 연산을 하는 코드는 이와 같다.

hash_index = (short)(key ^ (key>>16))   
//이렇게 보자. key>>16 은 keey의 상위 16비트를 아래로 끌어 내린것과 같다. 그리고 ^은 XOR연산으로 
//상위비트와 하위 비트를 XOR으로 섞게 된다. 이후에는 short 캐스팅으로 하위 16비트만 취한다.


폴딩 함수는 키를 여러 부분으로 나누어 모두 더한 값을 해시 주소로 사용한다. 키를 나누고 더하는 방법에는 이동 폴딩과 경계 폴딩을 쓴다.
이동폴딩은 키를 여러 부분으로 나눈 값들을 더하여 해시주소로 사용하고, 경계 폴딩을 키의 이웃한 부분을 거꾸로 더하여 해시 주소를 얻는다.

예를 들어 보자. 탐색키 하나가 있거니와 여러부분으로 나눈것이다.
123 | 203 | 241 | 112 | 20    
이동폴딩은 이대로 더하여 669의 주소를 사용하고
경계폴딩은 
123 | 302 | 241 | 211 | 20 이런식으로 바꾸고 더하여 897 이라는 주소를 쓴다.

*/

/*
탐색키가 문자열일 경우
대개 우선 문자열 안의 문자에 정수를 할당하여 바꾸면 된다. a 부터 z를 1부터 26까지 할당하듯 말이다.
다른 보편적 방법은 아스키코드값이나 유니코드값을 사용하는 것이다. 첫번째 문자의 아스키 코드 값으로 하는 방법이 일단 있다. 물론 이렇게 하면 첫 단어가 같은 알파벳은 구별이 안된다.

그렇기에 충돌을 막기 위해 대체적 방법은 문자열 안의 모든 문자의 아스키코드값을 더하는 것이다.
하지만 이 또한 다른 문제가 있다. 예컨대 cup 과 puc 이 두 단어를 구별이 불가능 하다. 또한 아스키 코드의 범위가 65에서 122이기에 해시코드가 합이 어느 범위에서 해시코드가 편향될 가능성 또한 있다.

이 방법도 있다. 글자들의 아스키 코드 값에 위치에 기초한 값을 곱하는 것이다. 
문자열 s가 n개의 문자를 가지고 있다고 가정하자, 그리고 s안의 i번째 문자가 u_i 라고 치자.
이렇게 구하는 것이다.
u_0*(g^n-1) + u_1 * (g^n-2) + ...+ u_(n-2)*g + u_n-1  

예시를 보면 쉽게 이해된다. cup으로 매칭시켜보자.
아스키 값은 각각 99 117 112 이다. 그리고 g는 마치 진수처럼 곱해지는 것으로, 자릿수에 얼마나 더 비중을 둘지에 대한 기수 라고봐도 된다.
g가 31이라고 치자.
99*31^2 + 117*31 + 112 이렇게 하는 것이다.

이를 함수로 만들면 이와 같다.

int hash_function(char* key){
	int hash_index = 0;
	while (*key)
		hash_index = g * hash_index + *key++; //기수 * 해쉬 인덱스 + 문자 아스키코드값, (이후 ++ 는 다음 문자로 이동함)
	return hash_index;
}

함수를 봐보자. cup기준으로 다시.
hash_index = 31 * 0 + 99 = 99
hash_index = 31 * 99 + 117  = 3186
hash_index = 31 * 3186 + 112 = 98878 이런식으로 호출이 되어지고 계산 된다.

즉 ((0 * g + u_0) * g + u_1) * g + u_2 이렇게 되는데, 이는 
= u_0 * g² + u₁*g¹ + u₂ 와 완전히 같아진다.

*/

/*ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ*/


/*
- 개방 주소법 -
충돌은 서로 다른 키를 갖는 항목들이 같은 해시주소를 갖게 되어, 같은 버킷, 그리고 다른 슬롯에 저장되는 형식이다.
그러나 슬롯마저, 다 차버린다면 오버플로우가 일어나게 된다. 이러한 오버플로우도 빈번하게 일어나기 때문에 해결방법이 필요하다. 크게 두가지가 있다.
1. 개방 주소법: 충돌이 일어난 항목을 해시 테이블의 다른 위치에 저장
2. 체이닝: 해시테이블의 하나의 위치가 여러개의 항목을 저장할 수 있도록 해시테이블의 구조를 변경한다. (의문점: ..? 그럼 슬롯을 더 늘리는 것인가..?)

우선 개방 주소법부터 시작하자. 개방 주소법은 선형,이차,이중,임의 조사법이 있다.


1) 선형 조사법 (linear probing)
특정 버킷에서 충돌이 발생하면 비어있는 버킷을 찾는 방법이다. 
해시테이블에서 빈 공간을 찾는 것을 조사 라고 한다.

선형 조사법은 만약 충돌이 arr[k] 에서 발생했다면 arr[k+1]이 비어 있는 지를 본다. 비어있지 않다면 arr[k+2]를 조사한다. 이런식으로 계속 조사하는 방법이다. 만약 테이블의 끝에 도달하면 다시 처음으로 가서 조사한다.
그리고 조사를 시작했던 곳으로 되돌아 오면 테이블이 가득 찬 것으로 판단한다.


이제 구현을 해보자, 먼저 해시 테이블은 1차원 배열로 구현되었으며, 키가 문자열로 되어있다.
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KEY_SIZE 10 //탐색키의 문자열 최대 길이
#define TABLE_SIZE 13 //헤싱 테이블의 크기(소수 값 13)

typedef struct{
	char key[KEY_SIZE];
} element;

element hash_table[TABLE_SIZE]; //해싱 테이블
//버킷당 하나의 슬롯을 가정한다.

void init_table(element ht[]) {
	int i;
	for (i = 0; i < TABLE_SIZE; i++) {
		ht[i].key[0] = NULL; //첫번째 문자를 NULL으로 모두 설정 및 초기화. 여기서는 첫 문자가 NULL이면 버킷이 빈 것으로 친다.
	}
}

int transform(char* key) {
	int number = 0;
	while (*key)
		number = 31 * number + *key++;
	return number;
}


int hash_function(char* key) {
	// 제산 함수를 이용한 해싱 함수
	int hash = transform(key) % TABLE_SIZE;
	if (hash < 0)
		hash += TABLE_SIZE;
	return hash;
}

//버킷 조사는 항상 원형으로 회전한다. 마지막에 도달하면 처음으로 간다는 것이다.

#define empty(item) (strlen(item.key)==0) //길이가 0인, 즉 키에 대응되는 현재 버킷이 비어있는지를 체크
#define equal(item1, item2) (!strcmp(item1.key, item2.key)) //두개의 항목이 동일한지를 본다. 원래 strcmp는 두 문자열이 같다면 0을 반환한다. if문의 사용을 위해 !을 붙였다. 즉 같다면 0이 아닌 다른 값을 반환한다.

//선형 조사법으로 테이블에 키를 삽입
void hash_lp_add(element item, element ht[]) {
	int i, hash_value;
	hash_value = i = hash_function(item.key); //해싱함수로 계산한 키 반환
	while (!empty(ht[i])) {
		if (equal(item, ht[i])) {
			//버킷안에 이미 들어있는 항목(키) 와 삽압하려는 키가 같다면 중복처리.
			fprintf(stderr, "탐색키가 중복되었습니다. \n");
			exit(1);
		}
		i = (i + 1) % TABLE_SIZE; //while문을 보자. 만약 처음으로 본 인덱스의 버킷이 비어있다면 실행되지 않고 넘어갓을것이다.
		//i는 +1 시켜 다음 인덱스 버킷을 본다. 단, 마지막에 도달하면 처음으로 도달해야 하기에, % TABLE_SIZE 을 추가로 해야한다.
		if (i == hash_value) {
			fprintf(stderr, "테이블이 가득찼습니다.");
			exit(1);
		}

	}
	ht[i] = item; //버킷에 단어를 삽입.

}

//탐색함수는 이렇게 한다. 먼저 키에 해시 함수를 적용시켜서 계산된 주소에서 항목을 찾는다.찾지 못한다면 선형조사법과 같은 방법으로 찾을 떄 까지 조사한다.
void hash_lp_search(element item, element ht[]) {
	int i, hash_value;
	hash_value = i = hash_function(item.key);
	while (!empty(ht[i])) {
		if (equal(item, ht[i])) {
			fprintf(stderr, "탐색 %s: 위치 = %d\n", item.key, i); 
			return;
		}
		i = (i + 1) % TABLE_SIZE;
		if (i == hash_value) {
			fprintf(stderr, "찾는 값이 테이블에 없음\n");
			return;
		}
	}
	fprintf(stderr, "찾는 값이 테이블에 없음\n");
}
//하지만 잘 생각해보자. 해싱함수에 의해 계산이 된 곳은 원래 있어야 할 곳이다. 충돌이 일어났을때 하나씩 인덱스를 +1 시키며 빈곳을 찾는것이다.
//이것도 마찬가지다. 계산이 된 곳을 보고, 이후 그 인덱스를 +1 시키며 계속 순회하는 것이다. 
//즉 이런 말과 같다. '전체 해쉬테이블을 조사하지 않았음에도 불구하고, 계속 순회하며 조사하다가 empty 상태를 만나면 바로 조사도 멈추고, 찾는 값이 테이블에 없다고 가정한다'

void hash_lp_print(element ht[]) {
	int i;
	printf("\n==================================\n");
	for (i = 0; i < TABLE_SIZE; i++) 
		printf("[%d] %s\n", i, ht[i].key); //각 인덱스 (버킷)의 번호와 버킷 안 항목 (키) 출력하게 한다.
	printf("\n================================\n\n");
}

int main() {
	init_table(hash_table);
	
	char* s[7] = { "do", "for", "if", "case", "else", "return", "funtion" }; //문법적으로 각 포인터들을 인덱스 항목마다 저장한 배열. 문자열은 첫번째 글자의 주소.
	element e;

	for (int i = 0; i < 7; i++) {
		strcpy(e.key, s[i]); //s[i]의 값을 e.key라는 배열에 복사. 즉 문자열 자체가 복사된다고 봐도 된다.
		hash_lp_add(e, hash_table); //키를 테이블에 삽입
		hash_lp_print(hash_table);
	}
	for (int i = 0; i < 7; i++) {
		strcpy(e.key, s[i]);
		hash_lp_search(e, hash_table);
	}
	return 0;

}
