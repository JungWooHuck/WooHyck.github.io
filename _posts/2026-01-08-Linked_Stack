#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

typedef int element;
typedef struct StackNode {
	element data;
	struct StackNode* link;
}StackNode;

typedef struct {
	StackNode* top;
}LinkedStackType;

void init(LinkedStackType* s) {
	s->top = NULL;
}

int is_empty(LinkedStackType* s) {
	return (s->top == NULL);
}

int is_full(LinkedStackType* s) {
	return 0;
}

void push(LinkedStackType* s, element item) {
	StackNode* temp = (StackNode*)malloc(sizeof(StackNode)); //하나의 노드 동적할당.
	temp->data = item; // 데이터삽입
	temp->link = s->top; //잘 생각하자. '스택의 삽입' 이다. 즉 맨 위에 한 요소를 올리는 것과 같다.
	//여기서는 temp의 링크필드에 top을 대입하였다. 즉 예컨데 a b NULL 이런식으로 있을경우, top은 a를 가르키고 있을 것이고, 이를 대입하면 마치 temp a b NULL 이 순서가 된다.
	s->top = temp; //이후 top조정.
}

void print_stack(LinkedStackType* s) {
	for (StackNode* p = s->top;p != NULL; p = p->link)
		printf("%d->", p->data);
	printf("NULL \n");
}

element pop(LinkedStackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택이 비어있음\n");
		exit(1);
	}
	else {
		StackNode* temp = s->top; //우선 대입을 한후
		int data = temp->data; //데이터는 pop의 성질인 스택에서 빼내오면서 동시에 값을 반환 을 수행시키기 위해 따로 또 저장.
		s->top = s->top->link; //top은 간단하게 다음 노드로 이동한 후
		free(temp); //미리 대입하였던 temp를 메모리 해제.
		return data;
	}
}

element peek(LinkedStackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택이 비어있음\n");
		exit(1);
	}

	else {
		return s->top->data;
	}
}

int main() {
	LinkedStackType s;
	init(&s);
	push(&s, 1); print_stack(&s);
	push(&s, 2); print_stack(&s);
	push(&s, 3); print_stack(&s);
	pop(&s); print_stack(&s);
	pop(&s); print_stack(&s);
	pop(&s); print_stack(&s);
	return 0;
} //의문점: 연결리스트로 스택을 구현할 시 책에서는 배열로 구현한 것보다 장점이 동적으로 크기제한없이 할당할 수 있다는 것과, 단점은 삽입과 삭제시 시간이 더 걸린다는 것이였다.
//그런데 배열로 구현할 경우에도 동적할당을 이용하여 구현하면 되는 것이 아닌가?

//답: 우선 가능하다. 두가지 방식 모두 다 가능하지만 차이가 있다.
//우선 연속메모리의 차이이다. 연결리스트의 경우에는 노드로 생성하기에 연속메모리가 아니지만, 배열로 구현할 경우 주소가 끊기지 않고 이어져 연속메모리가 된다.
//캐시 친화적: 프로그램이나 알고리즘이 CPU 캐시 메모리를 효율적으로 사용하도록 설계하는 것. CPU 가 데이터를 요청할 때 이미 캐시에 데이터가 있을 확률을 높여 빠른 속도로 데이터를 가져오게 하는 것.
// 위의 정의를 토대로 우선 메모리는 64비트 혹은 32비트 단위로 한 덩어리로 메모리를 가져온다. 이때, 배열은 연속메모리이기에, 캐시 히트율이 높지만, 
// 연결리스트로 구현한 것은 매번 새로운 노드 주소를 따라가야 하기 때문에, 상대적으로 느리다.

//저러한 배열의 장점이 있는 반면, 이런 단점도 있다. 배열로 구현할 경우 realloc으로 동적 할당을 해야하는데, 그렇게 된다면 기본 본래의 데이터들을 모두 복제해야 해서, 시간이 더 걸릴 수 있다.
