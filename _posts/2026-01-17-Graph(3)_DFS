//그래프의 탐색은 가장 기본적인 연산으로서 하나의 정점으로부터 시작하여 차례대로 모든 정점을 한 번씩 방문하는 것이다. 
//여러 문제를 탐색을 통해 해결할 수 있으며, 대표적으로 특정한 정점에서 다른 정점으로 갈수 있는지 없는지에 대한 유무이다.
//그래프의 탐색방법은 두가지로 깊이우선탐색(DFS), 너비우선탐색(BFS)으로 있다.
//깊이 우선 탐색부터 보자. 시작 정점에서 출발하여, 인접한 정점들 중에서 아직 반복하지 않은 정점을 선택한다. 만약 그러한 정점이 없다면 탐색은 종료한다.
//자세한건 코드에서 설명하겠다. 우선 깊이우선탐색의 구현은 스택을 이용하며, 추가적으로 재귀호출을 이용할 수도 있다.
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0 
#define MAX_VERTICES 50
typedef struct GraphType {
	int n; //정점의 개수
	int adj_mat[MAX_VERTICES][MAX_VERTICES];
}GraphType;

int visited[MAX_VERTICES];

void init(GraphType* g) {
	int r, c;
	g->n = 0;
	for (r = 0; r < MAX_VERTICES; r++)
		for (c = 0; c < MAX_VERTICES; c++)
			g->adj_mat[r][c] = 0;
}

void insert_vertex(GraphType* g, int v) {
	if (((g->n) + 1) > MAX_VERTICES) {
		fprintf(stderr, "그래프: 정점의 개수 초과");
		return;
	}
	g->n++;
}

void insert_edge(GraphType* g, int start, int end) {
	if (start >= g->n || end >= g->n) {
		fprintf(stderr, "그래프: 정점 번호 오류");
		return;
	}
	g->adj_mat[start][end] = 1;
	g->adj_mat[end][start] = 1;

}

void dfs_mat(GraphType* g, int v) {
	int w;
	visited[v] = TRUE; //visted배열은 정점들만을 저장해놓은 것으로, 방문기록 저장 용도이다.
	printf("정점 %d -> ", v); //방문한 정점을 먼저 출력한다.
	for (w = 0; w < g->n; w++) //정점의 수만큼 반복 진행
		if (g->adj_mat[v][w] && !visited[w]) //v는 시작점의 정점 번호로써, 그리고, adj_mat[v][w] 자체의 뜻이 시작 정점 v와 끝 정점 w 기준 사이의 간선이 있다는 뜻이다. 
			//즉 두 정점 사이에 간선이 있다면, 그리고 도착정점인 w이 아직 방문하지 않은 정점이라면
			dfs_mat(g, w); //정점 w에서 깊이 탐색 새로 시작
}

//첨부한 사진기준으로 만약에 시작정점이 0이라고 치자. 그리고 빈 스택 [] 이 있다.
//0이 들어간다. 바로 이후에 0의 스택에서 나오고 출력된 이후에 0의 자식인 1과 4가 들어간다. 그러면 스택은 [4,1] 이 된다.
//이후 스택에 후입선출의 방식으로 1이 먼저 나온다. 이후 1이 출력되고 1의 자식노드인 0과 2중 2가 들어간다. 0은 이미 방문되었기에 그러면 스택은 [4,2]가 된다.
// 같은 방식으로 2가 나오고 출력된후 2의 자식노드인 3이 스택에 들어간다. [4,3] 이후에 3이 나오고 출력되고 3의 자식노드를 찾지만 다 방문하였기에, 이 자체의 깊이우선탐색은 종료된다.
//이후 마지막으로 스택에 남아있는 4가 나오고 출력되고, 4 기준 또한 방문하지 않은 자식 노드가 없으므로 마친다.
//이로써 순서는 0,1,2,3,4 이렇게 된다. 이것이 스택기반으로 구현하는 것이다. 물론 그 본질은 방문 가능한 정점 중 하나를 선택해서 더 이상 갈 수 없을때까지 내려가는 것이다
int main() {
	GraphType* g;
	g = (GraphType*)malloc(sizeof(GraphType));
	init(g);
	for (int i = 0; i < 4; i++)
		insert_vertex(g, i);
	insert_edge(g, 0, 1);
	insert_edge(g, 0, 2);
	insert_edge(g, 0, 3);
	insert_edge(g, 1, 2);
	insert_edge(g, 2, 3);

	printf("깊이우선탐색\n");
	dfs_mat(g, 0);
	printf("\n");
	free(g);
	return 0;
}

//깊이 우선 탐색은 그래프의 모든 간선을 조사하게 되므로 정점의 수가 n이고 간선의 수가 e이라면 
//시간 복잡도는 인접리스트로 할 경우 O(n+e), 인접행렬은 O(n^2)이다. (각 정점 하나하나마다, 어찌되었든 전체의 정점 개수 n개를 계속 조사 하기 때문이다)
