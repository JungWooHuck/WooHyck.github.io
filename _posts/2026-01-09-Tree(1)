//트리를 공부하기 전, 용어와 개념에 대해서 공부해야 한다.
//노드: 트리의 구성요소, 루트: 가장 높은 곳에 있는 노드, 루트가 아닌 것을 서브트리라고 부른다. 항상 루트와 서브트리는 '간선'으로 연결된다.
//각 노드 사이는 부모, 형제, 자식, 자손 등의 관계가 있으며, 전체 트리에서의 루트를 기준으로 레벨 1, 그리고 아래로 갈수록 레벨이 올라간다.
//차수는 어떤 노드가 가지고 있는 자식노드의 개수를 뜻하며, 자식이 아예 없는 노드를 단말 노드(leaf) 라고 부른다. 전체 트리의 차수는 노드가 가지고 있는 차수 중 가장 큰 것을 대표한다.

//이진트리: 공집합이거나, 루트와 왼쪽 서브르리, 오른쪽 서브트리로 구성된 유한집합으로 정의된다. 이때, 이진트리의 서브트리들은 모두 이진트리여야 한다. 이때 자식 노드의 차수가 2 이하면 ok.
//이진트리의 성질: n개의 노드를 가진 이진트리는 항상 n-1 개의 간선을 갖는다. 이진트리에서의 노드는 루트를 제외하면 정확하게 하나의 부모노드를 가지기 때문이다.
//높이가 h인 이진트리인 경우 최소 h개의 노드를 가지면 최대 2^h -1 개의 노드를 가진다.  // 반대로 n개의 노드를 가지는 이진트리의 높이는 최소 [log(n+1)], 최대 n 이다. (이때 []는 올림 연산)

//이진트리의 분류: full binary tree: 트리의 각 레벨에 노드가 꽉 찬다. 즉 h의 높이면 노드는 2^n-1 개이다. // complete binary tree: 높이가 k일때, 레벨 1부터 k-1 까지는 노드가 모두 채워져 있고, 
//마지막 레벨에서는 왼쪽부터 오른쪽으로 순서대로 노드가 채워져 있는 이진트리이다. 마지막 레벨은 꽉 차있지 않아도 되지만, 중간의 빈곳은 허용하지 않는다.

//이진트리의 표현법: 1. 배열: 간단하게 숫자에 맞춰서 요소를 저장하는 것이다. 이때 일부로 인덱스 0 은 사용하지 않는다. 완전 혹은 포화 이진트리에 주로 사용하나, 다른 트리는 공간낭비가 심해진다.
// 2. 링크표현법: 트리에서의 노드가 구조체로 표현된다. 노드는 데이터 필드와 두개의 링크(포인터) 필드를 갖는다. 연결리스트와 비슷하게, 루트 노드를 가리키는 포인터만 있다면 모든 노드 접근이 가능해진다.


//이진트리의 순회:
//루트 방문을 V, 왼쪽서브트리 방문을 L, 오른쪽은 R이라고 치고, 항상 왼쪽 서브트리가 오른쪽 서브트리에 앞서서 방문한다고 가정하자.
//전위순회: VLR, 중위순회: LVR, 후위순회: LRV

//기억하자. 루트의 어떤 자식 노드는, 또 하나의 트리에서의 루트일 수 있다. 즉 이진트리의 순회는 순환을 이용한다.


#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

typedef struct TreeNode {
	int data;
	struct TreeNode* left, * right;
}TreeNode;

//			15
//	4			  20
// 1		  16	   25	


TreeNode n1 = { 1, NULL, NULL }; //자기 자신의 데이터와, 왼쪽 자식 트리, 오른쪽 자식 트리 (노드) 를 가르키게 하는 것이다.
TreeNode n2 = { 4, &n1, NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode* root = &n6;

void inorder(TreeNode* root) { //중위순회 방식
	if (root != NULL) { //의문점: 조건이 햇갈린다. root는 TreeNode 구조체의 포인터로, 이 구조체 포인터가 NULL이 되려면 data와 left, right 모두 NULL이 되어야 하는 것 아닌가? 
		//답: 맞다. 잘 생각해보자.  leaf 노드도 출력해야 한다 그럼 leaf도 root가 되어야 한다. 마찬가지로 leaf는 자식이 NULL이지만 데이터는 있으니까, leaf != NULL 이라서 출력된다
//순환이 결과적으로는 이렇게 된다. 왼쪽으로 갈 수 있을 때까지 계속 간다 막히면 오른쪽으로 이동
		inorder(root->left); //왼쪽서브트리 다시 순회 (순환 이용)
		printf("[%d] ", root->data);
		inorder(root->right);
	}
}

void preorder(TreeNode* root) { //전위 순위
	if (root != NULL) {
		printf("[%d] ", root->data); //루트 먼저 방문
		preorder(root->left);
		preorder(root->right);
	}
}

void postorder(TreeNode* root) {
	if (root != NULL) {
		postorder(root->left);
		postorder(root->right);
		printf("[%d] ", root->data);
	}
}
//순환문으로 부터, 출력은 root 에 대해서 밖에 없다. 즉 leaf노드에 대해서도 언젠간 루트로 보는 순간이 온다.

int main() {
	printf("중위순회=");
	inorder(root);
	printf("\n");

	printf("전위순회=");
	preorder(root);
	printf("\n");

	printf("후위순회=");
	postorder(root);
	printf("\n");
	return 0;
}
