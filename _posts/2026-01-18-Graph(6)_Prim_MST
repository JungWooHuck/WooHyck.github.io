//두번째 최소 비용 신장 트리를 구하는 방법으로 Prim의 MST알고리즘이다.
//이 알고리즘은 이렇게 보면 된다. 우선 시작 단게에서는 시작 정점만이 신장 트리 집합에 포함된다. 그리고 계속 앞단계에 만들어진 신장트리 집합에, 인접한 정점들 중에서 최저 간선으로 연결된 정점을 선택한다. 이를 간선 n-1개를 가질 때까지 계속한다.
//Kruskal의 알고리즘과 기뵤하면, Kruskal의 알고리즘은 간선을 기반으로 하는 알고리즘인 반면 Prim의 알고리즘은 정점을 기반으로 하는 알고리즘이다.
//또한 다른 점이 있다면 Kruskal의 알고리즘에서는 이전단계에서 만들어진 신장 트리와는 상관없이 무조건 최저간선만을 선택하는 탐욕적 방법이였던 것에 반하여, Prim의 알고리즘은 이전단계에서 만들어진 신장트리에서 확장하는 느낌이다.

//자 이제 구현해보자. 먼저 distance라는 정점의 개수 크기의 배열이 필요하다. 여기 안에는 신장트리 정점 집합에서 각 정점 까지의 거리를 가지고 있다. 처음에는 시작노드만 0으로 값을 설정하고 나머지는 무한대로 값을 가지게 한다.
//다음으로 우선순위 큐가 필요하다.  우선 순위 큐에 모든 정점을 삽입한다. 이때 우선순위는 distance 배열 값이 된다. 다음은 while 반복문으로 우선순위 큐에서 가장 작은 distance값을 가지는 정점을 끄집어 낸다. 그리고 이 정점이 트리 집합에 추가된다.

#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0 
#define MAX_VERTICES 100
#define INF 1000L

typedef struct GraphType {
	int n; //정점의 개수
	int weight[MAX_VERTICES][MAX_VERTICES];
}GraphType;

int selected[MAX_VERTICES]; //정점 어떤것이 이미 MST 트리 집합에 포함되었는가
int distance[MAX_VERTICES]; //현재 정점 기준 다른 정점으로 들어가는 가장 싼 간선 비용을 알아보기 위한
 //두 배열 모두 전역배열이기에 모두 배열요소가 0으로 저장된다.

int get_min_vertex(int n) {
	
	int v, i;
	for (i=0; i<n; i++)
		if (!selected[i]) {  //일단 아직 선택되지 않은 MST집합 밖에 있던 정점이 보이면 바로 v에 대입시킨다.
			v = i;
			break;
		}
	for (i = 0; i < n; i++) //이후 다시 선회를 하되, 만약 인덱스 i의 값중 선택되지 않은 즉 배열 요소가 0인 것을 찾았고 동시에, 
		//그 배열요소의 distance(MST집합에 붙일 수 있는 최소 비용) 가 더 적은 정점이 있다면 v를 그것으로 바꾼다. 이를 계속 반복한다.
		if (!selected[i] && (distance[i] < distance[v]))
			v = i; //이렇게 되면 for문으로 계속 v가 갱신되면서 최종적으로 가장 적은 비용이며 MST에 포함되지 않는 도착 정점을 찾을 수 있는 것이다,
	
	return (v); //즉  MST집합으로 붙일 수 있는 정점 중, 가장 비용이 싼 정점이 반환되게 된다.

}

void prim(GraphType* g, int s) { //s는 시작정점이다.
	int i, u, v;

	for (u = 0; u < g->n; u++)
		distance[u] = INF; //다른 것에 대해서는 가중치를 무한대로
	distance[s] = 0; //처음 시작정점은 0으로 둔다.
	for (i = 0; i < g->n; i++) {
		u = get_min_vertex(g->n); //이렇게 된다면 MST 집합으로부터 가장 비용이 적게 연결할수 있을 정점이 u에 저장되게 된다.
		selected[u] = TRUE; //이제 정점 u를 포함시키겠다고 지정한다.
		if (distance[u] == INF)
			return; //이 경우는 예외조건으로,  뽑힌 u의 distance가 INF의 상황으로 u로 가는 간선이 아예 없다는 뜻이다.
		printf("정점 %d 추가\n", u);
		for (v = 0; v < g->n; v++)  //새롭게 MST으로 들여온 정점 u의 모든 후보 이웃 v를 검사하는 것이다.
			if (g->weight[u][v] != INF) //어떤 새로운 v에 대해서 u-v 간선이 실제로 존재할 때만
				if (!selected[v] && g->weight[u][v] < distance[v]) //그리고 추가적으로, 그 v라는 정점이 MST에 포함이 안되어 있어야 하며, 동시에 u-v의 간선 가중치가 u정점을 추가하기전 MST의 최소비용보다 더 적다면  
					distance[v] = g->weight[u][v]; //갱신을 한다.
		//이건 이렇게 생각하면 된다. 기존의 MST에서의 집합에서 여전히 최소비용으로 된다면 유지하되, 새로 들어온 u가 임의 v를 연결했을때 더 좋은 비용이 (낮은 비용) 으로 된다면 갱신한다.
	}
}


//의문점: v는 get_min_vertex()처럼 “선택”되는 게 아니라 그냥 0 ~n - 1까지 무작정 순회한다
//만약 u 하나로 인해 distance[v]를 여러 개 갱신한다고 치자. 그러더라도 전체 MST에서 다음 u를 고를 때는 갱신되지도 않으면서 가장 최소 비용으로 할수 있는 정점 a(예: 10)이 선택된다고 생각하자.
//그럼 예시로 만약 원래 u로 인하여 v 갱신으로 인해서 b의 정점 (15 → 12로 갱신)는 당장 안 쓰이는데, 이 갱신이 불필요한 연산 아닌가 ? 다음 바깥 반복문에선 어차피 u가 a로 되기에..?

//답: 아니다 조금만 더 생각해보자. a를 기준으로 u가 설정된것은 맞겠지. 그럼 그 a를 기준으로 또 간선을 조사할것이다. MST와 말이다. 그럼 당연히 MST는 늘 현재기준 최선의 최소비용으로 계속 갱신해야 하는 것이 맞다. 정확한 비교를 위해서.
//물론 불필요한 과정이 많아 보일 수 있긴하다. 실제로도 시간복잡도는 O(n^2) 이기도 하고.
int main() {
	GraphType g = { 7,
		{{0,29,INF,INF,INF,10,INF},  //어찌되었든 간에, 그래프 알고리즘에서 입력 그래프를 하나하나 다 입력해야하는 것은 맞다.
		{29,0,16,INF,INF,INF,15},
		{INF,16,0,12,INF,INF,INF},
		{INF,INF,12,0,22,INF,18},
		{INF,INF,INF,22,0,27,25},
		{10,INF,INF,INF,27,0,INF},
		{INF,15,INF,18,25,INF,0}}
	};
	prim(&g, 0);
	return 0;
}

//의문점: Kruskal 와 비교하였을때, 이 코드를 봤을때는 시간복잡도도 효율적인 것이 아닌 오히려 prim의 방법이 더 느리다. Prim을 써야하는 이유가 있는가?
//답: 이 코드 기준으로는 맞아 보일 수 있는 말이다. 특히 희소 그래프에 있어서는 더욱더 Kruskal의 알고리즘과 비교하였을때 매우 비효율적인 코드가 된다.
// 하지만 차근차근 생각해보자. kruskal은 간선을 정렬하는데에 시간이 걸린다. 시간 복잡도는 O(E log E), Prim은 시간복잡도가 전에 설명하듯이 O(V²) 이 된다.이때 정점수를 V라고 하고, 간선수는 E이다.
// 만약 완전히 밀집 그래프라고 보자. 그러면 간선은 정점의 제곱에 비례하게 되어, kruskal의 시간복잡도는 최악의 경우 O(V²log V)가 된다. 즉 이럴 경우에는 Prim의 방법이 더 효율적이게 된다.

