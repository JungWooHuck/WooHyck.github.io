//우선순위 큐는 일반 큐와 스택과는 달리, 우선순위의 개념을 큐에 도입한 자료구조이다. 예를 들어서 네트워크 패킷 중에서 네트워크 관리와 관련된 패킷은 다른 일반 패킷보다 우선순위를 가진다. 
//도로의 차들을 생각해보자. 선입선출이 기본적으로  규칙이지만, 소방차나 구급차가 올경우에는 그런 규칙 없이 항상 우선순위가 1위가 된다. 마찬가지다.
//우선순위 큐는 배열과 연결리스트로 구현할 수 있으나, 삽입 혹은 삭제시에 각각 O(1), O(n) 으로 시간 복잡도가 생긴다. 따라서 삽입과 삭제모두 시간 복잡도가 O(logn) 으로 효율적으로 구현할 수 있는 '히프' 를 쓸 것이다.

//히프는 완전이진트리 기반의 자료구조 이며,  여러개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게  찾아내도록 만들어진 자료구조이다.  즉 다시 말하면, 부모 노드의 키값이 자식 노드의 키값보다 항상 큰 이진 트리이다.
//이때 아까 말한 것처럼 부모노드의 키 값이 자식 노드보다 큰 이진트리를 최대 히프, 반대로 키 값이 자식노드보다 작은 이진트리를 최소 히프라고 부른다.

//히프의 구현은 우선 배열로 생각해보자. 인덱스 0은 사용하지 않는 상태로, 그냥 차레대로 히프에 번호를 붙인후 그대로 대응되는 인덱스에 값을 저장한다. 이때 어떠한 노드 번호도 새로운 노드가 추가되어도 변하지 않는다.
//이떄 배열로 구현하였을때의 편리한 점이 있다. 결국 히프도 완전이진트리이기에 이런 법칙이 된다.  '왼쪽 자식의 인덱스 = 부모의 인덱스 * 2 // 오른쪽 자식의 인덱스 == 부모의 인덱스 * 2 + 1 // 부모의 인덱스 = 자식의 인덱스 / 2'

#include <stdio.h>
#include <stdlib.h>
#define MAX_ELEMENT 200
typedef struct {
	int key;
}element;

typedef struct {
	element heap[MAX_ELEMENT];
	int heap_size;
}HeapType;

//생성함수
HeapType* create() {
	return (HeapType*)malloc(sizeof(HeapType));
}

//초기화 함수
void init(HeapType* h) {
	h->heap_size = 0;
}
//heap_size는 말 그대로 heap에 들어있는 요소의 수이다. 초깃값 설정

//삽입함수.
void insert_max_heap(HeapType* h, element item) {
	int i;
	i = ++(h->heap_size);

	while ((i != 1) && (item.key > h->heap[i / 2].key)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item;
}
// 히프의 삽입은 이렇게 한다, 먼저 항상 새로운 노드를 히프의 마지막 노드로 삽입한다. 이후에 부모 노드와 그 노드의 값을 비교하며 교환한다. 이때 크면 교환하고, 크지 않다면 교환하지 않는다. 
// 단 코드의 구현내에서는 매번 교환하는 것이 아닌, 순회하면서 부모 노드만을 끌어내린 다음, 삽입될 위치가 확실해 진 다음에서야 그 새로운 노드 위치로 이동한다. 이제 코드를 보자.
// i는 히프의 요소수 + 1이다. 즉 본래 마지막노드에 연이은 곳을 가르키고 있는 것이다. 반복 조건문은 i가 1, 즉 root가 되거나, 삽입하려는 노드의 값이 그 노드의 부모 (자식노드 / 2)의 값보다 더 작다면 중단된다.
// 조건문을 만족한다면, i가 가르키고 있던 히프의 인덱스에 부모의 노드를 대입시킨다.
// 이후 조건문을 만족하지 않는 다면 그 위치가 삽입할 위치이다. 고로 item을 대입시킨다.

element delete_max_heap(HeapType* h) {
	int parent, child;
	element item, temp;

	item = h->heap[1];
	temp = h->heap[(h->heap_size)--];
	parent = 1;
	child = 2;

	while (child <= h->heap_size) {
		if ((child < h->heap_size) && (h->heap[child].key) < h->heap[child + 1].key)
			child++;
		if (temp.key >= h->heap[child].key) break;
		//한 단계 아래로 이동

		h->heap[parent] = h->heap[child];
		parent = child;
		child *= 2;
	}
	h->heap[parent] = temp;
	return item;

}
// 히프의 삭제는 최대 히프 기준, 가장 큰 값인 루트 노드가 항상 삭제된다. 그런 상황에서 빈 루트노드 자리에 히프의 마지막 노드를 가져온다.
// 이후에는 새로운 루트가 된 그 노드와 자식 노드를 비교하고, 이때 자식 노드가 더 크면 교환이 일어난다. 단, 자식 중에서 제일 큰 값과 교환이 일어난다. 이를 계속하여 자식 노드들 보다 큰 경우까지 반복한다.
// 이제 코드를 보자. item은 루트 노드 값이 되었고, temp는 히프의 마지막 노드 값이 되었다.
// 그리고 나서, parent에는 루트를 대표하는 번호 인덱스인 1을, child는 루트의 자식으로 2를 저장한다.
// 다음으로 반복문을 보자. child 가 우선 히프의 사이즈만큼 반복한다.
// 첫번째 조건문은 자식간의 크기를 비교하는 것이다. 무엇이든 간에 항상 자식들 중 큰 값으로 교체되기에, 만약 인덱스 2의 요소와 3을 비교하는데 3의 노드의 값이 더 크다면 2였던 child를 ++ 하는 것이다. 앞으로의 모든 반복문도 이처럼 된다.
// 두번째 조건문의 경우에는 이제 비교하는 것이다. 루트가 된 노드와 자식 노드와 비교하였을때, 루트노드의 값이 크다면 멈추고, 아니라면 아랫 코드로 가서 히프의 한 단계 아래로 이동한다.
// parent 였던 노드에 child노드를 대입 시킨다. 이후 child 노드부터 시작해서 이제 그 노드를 parent으로 둔다. child는  *2 를 하여서 알맞게 새롭게 배치된 parent노드의 자식 노드가 되도록 한다.
// 모든 과정을 끝낸 후 h->heap[parent] 를 temp으로 대입 시킨다. 


int main() {
	element e1 = { 10 }, e2 = { 5 }, e3 = { 30 };
	element e4, e5, e6;
	HeapType* heap;

	heap = create(); //히프 생성
	init(heap); 

	insert_max_heap(heap, e1);
	insert_max_heap(heap, e2);
	insert_max_heap(heap, e3);

	e4 = delete_max_heap(heap);
	printf("< %d > ", e4.key);
	e5 = delete_max_heap(heap);
	printf("< %d > ", e5.key);
	e6 = delete_max_heap(heap);
	printf("< %d > ", e6.key);

	free(heap);
	return 0;

}


//힙 정렬
void heap_sort(element a[], int n) {
	int i;
	HeapType* h;

	h = create();
	init(h);
	for (i = 0; i < n; i++) {
		insert_max_heap(h, a[i]);
	}
	for (i = (n - 1); i >= 0; i++) {
		a[i] = delete_max_heap(h);
	}
	free(h);
}

#define SIZE 8 
int main() {
	element list[SIZE] = { 23,56,11,9,56,99,37,34 };
	heap_sort(list, SIZE);
	for (int i = 0; i < SIZE; i++) {
		printf("%d ", list[i].key);
	}
	printf("\n");
	return 0;
}
//정렬되어있지 않은 데이터들이 1차원 배열에 저장되있다고 치자. 이것들을 최대히프에 추가한뒤 뒤의 요소부터, 혹은 앞의 요소부터 원하는대로 배열에 차례대로 다시 넣으면 정렬이 된다.
//의문점: 히프에서는 부모와 자식간의 관계만 명확하지 형제관계에서의 관계는 명확하지 않기에 정렬이 안되지 않나?
//답: 맞다. 히프에서는 형제관계에 대한 정확한 정렬이 불가능하다. 즉, 이 정렬은 이럴때만 사용 가능한다. 예컨대 "가장 큰 값 5가지" 라든가, "가장 작은 값 3가지" 를 찾는 등.
