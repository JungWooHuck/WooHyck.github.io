//합병정렬
//합병정렬은 하나의 리스트를 두개의 균등한 크기로 분할하고 분할된 부분리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트를 얻고자 하는 것이다.
//이때 부분리스트의 크기가 완전히 쪼개지지 않았다면 계속 2개의 부분배열로 또 분할한다. 이 분할은 순환 호출을 이용한다
//합병 정렬에서 실제로 정렬이 이루어지는 시점을 두개의 리스트를 합병하는 단계이다. 합병하는 알고리즘은 이렇게 작성한다.
//리스트 두개 (1,3,5,7) 과 (2,4,6) 이 있다고 하자.그리고 새로운 빈 리스트 () 를 생성한다.
//리스트의 요소들을 하나씩 처음부터 비교하여 두개의 리스트의 요소 중에서 더 작은 요소를 빈 리스트에 옮긴다. 예컨대, 처음은 (3,5,7), (2,4,6), (1) 이렇게 될 것이다.
//이것을 이제 반복한다. 그다음은 3과 2가 비교되어 (3,5,7), (4,6), (1) 이렇게 될것이다. 이렇게 두개의 리스트 중 하나가 먼저 끝날때 까지 반복하거니와, 한쪽의 리스트가 먼저 끝나면 나머지 리스트는 그대로 전부 새 리스트에 복사한다.

//이제 구현을 해보자.  
//merge_sort 함수에서 주어진 list배열은 2등분하여 각각의 부분 배열에 대하여 다시 merge_sort 함수를 순환 호출한다. 
//이를  부분배열에 요소가 하나 남을 때 까지 계속하고, 이러한 분할 과정이 끝나서야 정렬된 부분 배열을 merge함수를 이용하여 합병한다.

int sorted[MAX_SIZE]; //추가 공간 필요

/* i는 정렬된 왼쪽 리스트에 대한 인덱스
   j는 정렬된 오른쪽 리스트에 대한 인덱스
   k는 정렬될 리스트에 대한 인덱스 */

void merge(int list[], int left, int mid, int right) {
	int i, j, k, l;
	i = left; j = mid + 1; k = left;

	
	while (i <= mid && j <= right) {
		if (list[i] <= list[j]) //만약 오른쪽 리스트 요소가 더 크다면 왼쪽 리스트 요소를 새로운 빈 리스트배열에 대입
			sorted[k++] = list[i++];
		else
			sorted[k++] = list[j++];
	}

	if (i > mid) //만약 왼쪽 분할 되었던 리스트의 인덱스인 i가 mid를 벗어난다면. 즉 배열의 끝에 도달했다면
		for (l = j; l <= right; l++) //다른	리스트배열의 오른쪽 부분 리스트의 남은 요소들을 모두 복사.
			sorted[k++] = list[l];
	else //반대의 경우는 반대로
		for (l = i; l <= mid; l++)
			sorted[k++] = list[l];

	for (l = left; l <= right; l++)
		list[l] = sorted[l];  //새로 만들었던 합병을 마친 리스트를 이제 기존 리스트에 모두 복사

}

void merge_sort(int list[], int left, int right) {
	int mid;
	if (left < right) { //각 부분리스트에 요소가 1개가 남을 때 까지 쪼갠다
		mid = (left + right) / 2;  //균등 분할
		merge_sort(list, left, mid); //이제 left, mid 범위의 부분리스트에 대해서 merge_sort 호출
		merge_sort(list, mid + 1, right);
		merge(list, left, mid, right); //합병으로,  첫 시작은 순환 재귀호출이 끝나고 돌아오면서, 한개의 요소끼리 있는 부분리스트 끼리의 합병으로 시작이 될 것이다.

	}
}

//예를 들어보자 배열 [8,3,5,1] 으로 생각하자.
// merge_sort([8,3,5,1]) 에서 left= 0, right=3 (인덱스), mid = 1이 된다. 
//이는 이제 아래로 내려오거니와, 순환호출로, merge_sort(0,1) 과 merge_sort(2,3) 을 한다. 이때 각 호출에 있어어도, 다시 함수를 실행하지만,
//merge_sort(0,0), merge_sort(1,1) //merge_sort(2,2), merge_sort(3,3) 이렇게 호출이 각각 되어, if문  (left < right) 에 걸리게 된다. 이후 다시 천천히 돌아오며, 
// merge_sort(0,1) 에선 merge(list, 0,0,1) 이 실행되고,  merge_sort(2,3) 에서는 merge(list, 2,2,3) 이 실행된다. 그럼 합병의 결과는 [3, 8]과, [1,5] 가 된다.
// 이후 마지막으로 merge(0,1,3)이 실행되어서 [1,3,5,8] 이 된다.


//이제 복잡도를 봐보자. 레코드의 개수 n이 2의 거듭제곱이라고 가정하자. 만약 n=2^3 일 경우 부분배열의 크기는 계속 절반씩 줄어드는 즉 2^3->2^2->2->1 이런식으로 줄어들 것이고, 동시에 순환 호출의 깊이가 3임을 알 수 있다.
//즉 순환 호출의 깊이는 n=2^k 라고 한다면 깊이는  k가 될 것이다.이때의 k는 logn 이다.
//코드를 그리고 보면 알지만, 배열이 부분 배열로 나누어지는 단계는 비교연산과 이동연산 모두 수행되지 않는다. 오로지 부분 배열이 합쳐지는 merge 합병 단계에서만 수행된다.
//비교연산이 그러면 각 합병 단계에서 얼마나 될까, n=2^3 으로 봐보자. 크기 1인 부분배열 2개를 합병하는데는 최대 2개의 비교연산이 필요하고, 이러한 부분배열의 쌍이 4개이므로, 2*4 = 8번의 비교연산이 필요하다.
//마찬가지로 다음 단계로 봐보자. 크기 2인 부분배열 2개를 합병하는 데에는 최대 4개의 비교연산이 필요하다. 이러한 쌍이 2개 이므로, 4*2 = 8 번으로 똑같다.
//그럼 k=logn 으로 합병단계 깊이 수이므로, 총 비교 연산은 nlogn 번 이다. 

//이동연산은 이렇게 된다. 요소수에 맞춰서 새로운 빈 배열에 임시로 복사했다가 다시 가져와 대입시킨다. 즉 요소수가 n이라면 이동은 2n번 이루어 진다. 따라서 합병단계가 logn 이므로, 
//이동연산은 2nlogn 이다.

//합병 정렬은 복잡도 O(nlogn)을 가지는 알고리즘이다.
//또한 안정적인 정렬 방법이며, 입력데이터가 무엇이든 간에, 정렬되는 시간은 동일하다.

//단점의 경우, 볼 수 있듯, 하나의 빈 임시 배열을 사용했을 뿐 아니라, 만약 레코드들의 크기와 수가 엄청 크다면 이동횟수가 많으므로 시간이 오래 걸린다.
//그러나 만약 레코드를 연결리스트로 구성하여 합병 정렬할 경우, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다. 
//이렇게 보자. 연결리스트는 노드를 움직일 필요가 없다 즉, 링크필드에 있는 포인터만 다른 곳을 가르키게 하면 된다.
// 
//따라서 크기가 큰 레코드를 정렬할 경우 만약 연결 리스트를 사용한다면 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적일 수 있다.
