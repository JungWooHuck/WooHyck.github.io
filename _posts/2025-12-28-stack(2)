3. 동적 배열 스택.

#include <stdio.h>
#include <stdlib.h>
#define MAX_STACK_SIZE 100 //책에는 있던 코드였으나 없어도 된다. 구현에 있어서 전혀 쓰지 않는다.

typedef int element;
typedef struct {
	element* data; //의문점: 왜..?  그동안 element형의 배열로 선언되지 않았나..? 
	//답: 동적할당을 위한 것이다. 이 코드의 경우에는 컴파일 시간에 크기가 딱 정하는 배열의 정적 성질이 아닌, 
	//실행 도중에, 필요한 만큼 heap에서 메모리를 가져오는 식의 동적 구현을 위해서다. 그러기 위해서는 항상 포인터이어야 한다.
	int capacity; //현재 크기
	int top;
}StackType;

void init_stack(StackType* s) {
	s->top = -1;
	s->capacity = 1;
	s->data = (element*)malloc(s->capacity * sizeof(element)); //여기에서 크기 1개 만큼의 동적할당을 한다.
}

int is_empty(StackType* s) {
	return  (s->top == -1);
}

int is_full(StackType* s) {
	return (s->top == (s->capacity - 1));
}

void push(StackType* s, element item) {
	if (is_full(s)) {
		s->capacity *= 2; //의문점: 공간의 손해를 보더라도 +1이 아닌, *=2로 하는 이유..? //추측점: 어차피 heap공간에서 금방 반환되고 다시 쓸 수 있는 메모리라서..? 아니면, 공간보다 시간이 더 중요하니까?
		//답: 만약 계속 +1을 한다고 치자, 그럼  한번 push 할때마다 무조건 한번 reolloc를 해야하는 즉, 시간 복잡도가,  O(N^2) 가 된다.
		//realloc 는 기존의 요소를 냅두고 추가한다고는 하지만, i번째 realloc 시에는 i개의 요소를 (이미 있던 데이터들을) 모두 복사해야 한다
		s->data =
			(element*)realloc(s->data, s->capacity * sizeof(element));
	}
	s->data[++(s->top)] = item;
}

element pop(StackType* s) {
	if (is_empty(s)) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return s->data[(s->top)--];
}

int main() {
	StackType s;
	init_stack(&s);
	push(&s, 1);
	push(&s, 2);
	push(&s, 3);
	printf("%d \n", pop(&s));
	printf("%d \n", pop(&s));
	printf("%d \n", pop(&s));
	free(s.data); //동적할당을 하였으므로 메모리 반납 필수.
	return 0;
}
//단일 push 의 경우에는 realloc가 안 일어나면 O(1), realloc가 일어날 경우에는 O(n)이다.
//이때, 그래서 특정 연산의 비용이 가변적이므로 상각 분석 (Amortized Analysis) 으로, 쉽게 말해, 전체의 수행 비용을 평균을 내어 보는 것인데,
// *2 으로 하는 방식은 ((총 비용) O(N) / (연산수) N )으로 O(1) 이 된다
// capacty가 *2가 되고 realloc 가 일어나는 경우는 1,2, 4, 8, 16  경우로 즉 그 횟수는 log N이다.
// realloc없는 push의 경우에는 O(1) 이다. 이것이 대부분의 push를 차지할 것이기에, N번 실행하였을때 총 비용 시간 복잡도는 O(N)
// realloc을 일으키는 push의 경우네는 전체에 비해 매우 적다. 1,2,4,8,16,32,64....그렇게 해서 N까지의 원소를 복사하는데가 비용인데 이 전체가 2N보다 작으므로
// 이 경우의 총 비용은 O(N)이다. 따라서 전체 push의 총비용은 O(N) + O(N) = O(N) 이다. 
