//삽입 정렬
//삽입 정렬은  정렬되어 있는 리스트에 새로운 레코드를 적절한 위치에 삽입하는 과정을 반복한다.
//이런 식으로 생각하자. 하나의 전체 배열을 정렬된 부분과 정렬이 안된 부분이라고. 첫 반복은 첫 요소만이 정렬된 부분이 되고, 정렬이 안된 부분의 첫 요소는 두번째 인덱스가 될 것이다. 
//이제 그 요소를 정렬된 부분에 적당한 위치에 삽입하거니와, 정렬된 부분의 크기를 +1하고 정렬되지 않은 부분은  크기를 -1 시킨다. 마치 손 안의 카드를 정렬하는 방법과 비슷하다.
//이때 삽입의 정확한 방법은 이것이다. 예컨대 정렬 되어진 부분이 2 5 7 이렇게 되어있고, 정렬 안된 첫 부분 인덱스의 요소가 4 이라고 치자.
//4과 7이 먼저 비교되거니와, 7은 4이 있던 자리로 한칸 밀어난다. 이번엔 4과 5를 비교한다. 마찬가지로 5가 밀려난다. 4와 2가 비교된다. 4가 더 크므로 반복을 멈추거니와 이제 그 자리에 4가 삽입된다.

void insertion_sort(int list[], int n) {
	int i, j, key;
	for (i = 1; i < n; i++) { //인덱스 1부터 시작한다. 인덱스 0은 이미 정렬된 거와 다름없다.
		key = list[i]; //삽입을 할 숫자를 key에 저장한다.
		for (j = i - 1; j >= 0 && list[j] > key; j--) //잘 보자.. j는 i의 바로 전 인덱스로 '정렬이 된 부분' 일 것이다. 
			//이후 조건식을 보자. j. 즉 인덱스가 음수가 되거나, 동시에 key의 값이 (순회하다가) 정렬된 부분의 요소보다 크면 반복을 멈춘다.
			list[j + 1] = list[j]; //레코드의 오른쪽으로 한칸 씩 밀려난다.
		list[j + 1] = key; //조사를 다 마쳣다면 바로 삽입한다.
	}
}

//복잡도를 보자. 삽입정렬은 정렬 상태에 따라서 시간 복잡도가 변한다.  만약 입력 자료가 이미 어느정도 정렬되어 있는 상태라면 가장 빠른 삽입의 방법일 것이다.
//삽입 정렬의 외부 루프는 n-1번 이고 각 단계에서 1번의 비교와 2번의 이동만 이루어 지므로, 총 비교횟수는 n-1번, 총 이동횟수는 2(n-1) 이 되어 알고리즘의 시간 복잡도는 O(n)이다.

//최악은 역순으로 입력이 정렬된 것이다. 각 단계에서 앞에 놓인 자료들은 전부 한 칸씩 뒹로 이동해야 한다. 따라서 외부 루프안의 각 반복마다 i번의 비교가 수행되므로, 시간 복잡도는 O(n^2) 가 된다.
//총 이동 횟수도 외부 루프의 각 단계마다 i+2 번의 이동이 이루어지므로, O(n^2) 이다.

//삽입정렬은 안정한 정렬 방법이며, 대부분의 레코드가 정렬되어 있거나, 레코드 크기 자체가 많지 않을 경우에는 유용하다.
//그러나 레코드 크기가 클 경우에는 적합하지 않다.

//버블 정렬
//버블 정렬은 인접한 2개의 레코드를 비교하여, 크기가 순서대로 되지 않으면 서로 교환하는 방식이다. 이를 리스트의 마지막까지 반복한다.
//구현과 알고리즘 모두 매우 간단하다.

#define SWAP(x,y,t) ( (t)=(x), (x)=(y), (y)=(t))  //교환

void bubble_sort(int list[], int n) {
	int i, j, temp;
	for (i = n - 1; i > 0; i--) {
		for (j = 0; j < i; j++)
			if (list[j] > list[j + 1])
				SWAP(list[j], list[j + 1], temp);
	}
}
//하나의 스캔은 j=0 부터 j=i-1 까지 반복하는 루프로 구성되어 있다.
//그리고 한번의 스캔을 마칠때마다, (정렬이 안된) 요소들 중 가장 큰 값은 맨 오른쪽에 (정렬된 부분 제외) 위치하는, 즉 각 스캔마다 최댓값을 찾아 내는 그런 정렬으로봐도 된다.
//그렇기에 저렇게 반복문이 되는것이다. 전체 배열이 모두 반복 ( n-1번) 하되, 정렬된 부분은 한 스캔 마다 늘어나기에, 내부 반복문은 하나의 스캔이 끝날때마다 -1 되는 i를 이용하여 표현한거다.

//복잡도를 보자. 버블 정렬의 비교 횟수는 어떠한 상황에서도 항상 일정하며, 항상 O(n^2)이다.
//다음은 이동횟수이다. 최악의 경우는 모든 입력자료가 역순으로 정렬되어 있는 경우이며, 한 차례의 이동에 대해서 총 3번의 이동이 이루어 진다. 
//최선은 모두 이미 정렬이 된 경우로 이동이 한번도 이루어 지지 않는다. 평균적의 경우에는 자료이동이 0번에서 i번까지 같은 확률로 일어나기에, 이를 기반으로 보면 O(n^2) 이 된다.

//버블정렬은 코드의 단순성에 불구하더라도 거의 쓰이지 않고 있다.
